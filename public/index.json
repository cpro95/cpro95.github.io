
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    [{"authors":null,"categories":null,"content":"웹 개발 배우기 4편 - 자바스크립트 조건문, 불리언과 if문으로 논리 마스터하기 ‘웹 개발 배우기’ 시리즈의 네 번째 시간입니다.\n이번 챕터에서는 특정 조건이 만족될 때만 코드를 실행하는 아주 중요한 도구들에 대해 알아볼 텐데요.\n바로 ‘불리언(Boolean)’, ‘비교’, 그리고 ‘if 문’입니다.\n새로운 데이터 타입, 불리언 이 두 타입은 0, -5, 7.1처럼 수많은 값을 가질 수 있습니다.\n하지만 불리언은 좀 다른데요.\n이 데이터 타입의 값은 true(참)와 false(거짓), 딱 두 가지뿐입니다.\n보통 예/아니오로 답할 수 있는 질문에 대한 결과로 이 값들이 반환되거든요.\n예를 들어 Number.isInteger() 메소드는 주어진 값이 정수인지 아닌지 알려줍니다.\n\u0026gt; Number.isInteger(1) true \u0026gt; Number.isInteger(5.0) true \u0026gt; Number.isInteger(5.1) false 문자열에는 특정 문자열로 시작하는지 알려주는 .startsWith() 메소드가 있는데요.\n\u0026gt; \u0026#39;잘 지내세요?\u0026#39;.startsWith(\u0026#39;잘\u0026#39;) true \u0026gt; \u0026#39;잘 지내세요?\u0026#39;.startsWith(\u0026#39;왜\u0026#39;) false 배열에는 특정 요소를 포함하고 있는지 확인하는 .includes() 메소드도 있습니다.\n\u0026gt; [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;].includes(\u0026#39;a\u0026#39;) true \u0026gt; [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;].includes(\u0026#39;x\u0026#39;) false 원시 값과 객체, 자바스크립트 값의 두 종류 자바스크립트는 값을 크게 두 종류로 구분합니다.\n하나는 undefined, 불리언, 숫자, 문자열 같은 ‘원시 값(primitive value)‘이고, 다른 하나는 배열 같은 ‘객체(object)‘입니다.\n원시 값은 단일 값을 가지며, 절대 변경할 수 없는 ‘불변성’을 특징으로 하는데요.\n반면 객체는 여러 값을 담을 수 있으며, 생성된 후에도 내용을 바꿀 수 있는 ‘가변성’을 가집니다.\n객체를 변수에 할당하면 그 객체가 변수 안에 그대로 저장되는 것처럼 보이는데요.\n하지만 실제 내부 동작 방식은 조금 다릅니다.\n객체는 ‘힙(heap)‘이라는 별도의 메모리 공간에 저장되고, 변수에는 그 객체를 가리키는 고유한 ‘주소(identity)‘만 담기게 되거든요.\n이 때문에 두 변수에 같은 객체를 할당하면, 두 변수는 메모리상의 동일한 객체를 ‘공유’하게 됩니다.\nconst arr1 = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]; const arr2 = arr1; // 배열 자체가 아닌 주소를 복사 이제 arr1과 arr2는 같은 배열을 가리키고 있는 건데요.\n그래서 arr1을 통해 배열을 수정하면 arr2에도 똑같이 반영됩니다.\n\u0026gt; arr1[1] = \u0026#39;x\u0026#39;; \u0026gt; arr1 [ \u0026#39;a\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;c\u0026#39; ] \u0026gt; arr2 [ \u0026#39;a\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;c\u0026#39; ] 두 변수가 같은 대상을 바라보고 있기 때문에 나타나는 현상입니다.\n엄격한 동등 연산자 === 참고로 ==라는 느슨한 동등 연산자도 있지만, 예상치 못한 결과를 낳을 수 있어 초보자라면 사용하지 않는 것을 강력히 추천합니다.\n원시 값의 경우 ===는 내용물이 같은지를 비교하거든요.\n\u0026gt; 1 === 1 true \u0026gt; \u0026#39;hello\u0026#39; === \u0026#39;hello\u0026#39; true 하지만 객체의 경우 ===는 내용이 아닌 ‘주소’가 같은지를 비교합니다.\n그래서 내용물이 똑같아 보여도, 서로 다른 객체라면 false를 반환하는데요.\n이 점이 객체 비교에서 가장 헷갈리기 쉬운 부분입니다.\n\u0026gt; [] === [] false 두 개의 빈 배열은 내용물은 같지만, 메모리상에서는 서로 다른 주소를 가진 별개의 객체이기 때문입니다.\n그 외 비교 연산자 \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 숫자를 비교할 때는 우리가 예상하는 대로 작동하지만, 문자열을 비교할 때는 사전 순서대로 비교합니다.\n\u0026gt; \u0026#39;가방\u0026#39; \u0026lt; \u0026#39;바나나\u0026#39; true 다만 대문자가 소문자보다 ‘크다’고 판단하는 등 몇 가지 주의할 점이 있습니다.\n불리언을 위한 논리 연산자 \u0026amp;\u0026amp;, ||, ! \u0026amp;\u0026amp; 연산자는 양쪽 모두 true일 때만 true를 반환하고, || 연산자는 둘 중 하나라도 true이면 true를 반환합니다.\n! 연산자는 불리언 값을 반대로 뒤집는 역할을 하거든요.\n\u0026gt; !true false \u0026gt; !false true 이 연산자들을 활용하면 특정 값이 주어진 범위 안에 있는지 확인하는 함수도 쉽게 만들 수 있습니다.\nconst isBetween = (lower, upper, value) =\u0026gt; { return value \u0026gt;= lower \u0026amp;\u0026amp; value \u0026lt;= upper; }; 이 함수는 value가 lower 이상’이고’ upper 이하’일 때만 true를 반환합니다.\nif 조건문 if 문의 괄호 안에 있는 조건이 true일 경우에만 중괄호 안의 코드가 실행됩니다.\nif (조건) { // 조건이 true일 때만 실행되는 코드 } else를 사용하면 조건이 false일 때 실행될 코드를 추가할 수 있고, else if를 사용하면 여러 개의 조건을 연달아 확인할 수도 있습니다.\nconst describeNumber = num =\u0026gt; { if (Number.isNaN(num)) { return \u0026#34;숫자가 아닙니다\u0026#34;; } else if (Number.isInteger(num)) { return \u0026#34;정수입니다\u0026#34;; } else { return \u0026#34;실수입니다\u0026#34;; } }; 이 함수는 입력받은 num이 숫자가 아닌지, 정수인지, 혹은 그 외의 실수인지를 순서대로 확인하여 해당하는 설명을 반환합니다.\n프로젝트 숫자 맞추기 게임 게임이 시작되면 컴퓨터는 정해진 범위 내에서 무작위 숫자를 하나 생각합니다.\n사용자는 숫자를 입력하고, 컴퓨터는 사용자의 추측이 정답보다 높은지, 낮은지, 아니면 정답인지를 알려주는 방식이거든요.\n이 게임의 핵심 로직은 if-else if-else 구조로 이루어져 있습니다.\nconst continueGame = guessedNumber =\u0026gt; { // ... (입력값 유효성 검사) ... if (guessedNumber === randomNumber) { feedback.innerText = \u0026#34;✅ 정답입니다!\u0026#34;; // 게임 종료 처리 } else if (guessedNumber \u0026lt; randomNumber) { feedback.innerText = \u0026#34;제가 생각한 숫자보다 작네요.\u0026#34;; } else { feedback.innerText = \u0026#34;제가 생각한 숫자보다 크네요.\u0026#34;; } }; 먼저 사용자의 입력값이 유효한 숫자인지, 그리고 정해진 범위 내에 있는지 확인합니다.\n유효한 추측이라면, if 문을 통해 정답과 비교하여 세 가지 경우에 따라 각기 다른 피드백을 화면에 보여주는 거죠.\n사용자가 정답을 맞히면 게임이 종료되고, 더 이상 추측을 입력할 수 없도록 입력 필드와 버튼을 비활성화합니다.\n","date":1758245042,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"f715a5190585506c344c5f475f6eebc7","permalink":"http://localhost:1313/posts/2025-09-19-learning-web-dev-part4-javascript-booleans-if/","publishdate":"2025-09-19T10:24:02+09:00","relpermalink":"/posts/2025-09-19-learning-web-dev-part4-javascript-booleans-if/","section":"posts","summary":"웹 개발 배우기 4편에서는 자바스크립트의 핵심 논리 도구인 불리언, 비교 연산자, if 조건문을 배웁니다. 숫자 맞추기 게임 예제를 통해 코드의 흐름을 제어하는 방법을 익혀보세요.","tags":["웹 개발 배우기","자바스크립트 기초","자바스크립트 불리언","if 조건문","비교 연산자","논리 연산자","숫자 맞추기 게임"],"title":"웹 개발 배우기 4편 - 자바스크립트 조건문, 불리언과 if문으로 논리 마스터하기","type":"posts"},{"authors":null,"categories":null,"content":"웹 개발 배우기 3편 - 자바스크립트 배열 완전 정복, 여러 데이터를 한 번에 관리하기 ‘웹 개발 배우기’ 시리즈의 세 번째 시간이 돌아왔는데요.\n이번 챕터에서는 하나의 변수에 여러 개의 값을 저장하는 방법, 바로 ‘배열(Array)‘에 대해 자세히 알아볼 예정입니다.\n배열 여러 값을 하나의 변수에 담기 이제부터 배열이 어떻게 작동하는지 함께 살펴보겠습니다.\n먼저 배열을 하나 만들어 arr이라는 변수에 할당해 볼 텐데요.\n코드는 이렇게 작성합니다.\n\u0026gt; const arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; 이렇게 하면 세 개의 문자열을 담고 있는 배열 하나가 만들어집니다.\n배열을 만드는 문법은 대괄호 []로 시작해서 쉼표로 구분된 요소들을 나열하고, 다시 대괄호로 닫는 방식이거든요.\n이런 문법을 ‘배열 리터럴’이라고 부르는데, 우리는 이미 숫자 리터럴(5, -2)이나 문자열 리터럴(\u0026#39;abc\u0026#39;) 같은 것들을 본 적이 있습니다.\n배열에 몇 개의 요소가 들어있는지는 .length로 확인할 수 있거든요.\n\u0026gt; arr.length 3 결과는 3이 나옵니다.\n배열의 각 요소에는 0부터 시작하는 ‘인덱스(index)‘라는 번호를 통해 접근할 수 있는데요.\n요소를 읽어올 수도 있고,\n\u0026gt; arr[0] \u0026#39;a\u0026#39; 새로운 값으로 바꿀 수도 있습니다.\n\u0026gt; arr[0] = \u0026#39;x\u0026#39;; \u0026gt; arr [ \u0026#39;x\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ] 배열의 마지막 요소 인덱스는 항상 .length - 1이거든요.\n이 점은 꼭 기억해두시는 것이 좋습니다.\n\u0026gt; arr[arr.length - 1] \u0026#39;c\u0026#39; 이렇게 여러 값을 담고 쉽게 접근할 수 있게 해주는 구조를 ‘데이터 구조’라고 부르는데요.\n배열은 바로 이 데이터 구조의 한 종류입니다.\nconst로 선언해도 배열은 바꿀 수 있어요 const는 변수라는 상자 자체를 다른 것으로 교체하지 못하게 막을 뿐, 상자 안에 들어있는 내용물이 ‘변경 가능한(mutable)’ 값이라면 그 내용물을 바꾸는 것까지 막지는 못합니다.\n참고로 숫자나 문자열은 ‘변경 불가능한(immutable)’ 값이라서, 값을 바꾸는 것처럼 보여도 실제로는 새로운 값으로 교체되는 것이거든요.\n아래 코드에서 num 변수에 담긴 숫자 0이 바뀌는 게 아니라, num + 1의 결과인 새로운 숫자 1이 num이라는 상자에 새로 담기는 원리입니다.\nlet num = 0; num = num + 1; 한 줄 주석과 여러 줄 주석 자바스크립트에는 여러 줄에 걸쳐 주석을 작성할 수 있는 ‘여러 줄 주석’도 있습니다.\n/*로 시작해서 */로 끝나거든요.\n/* 이렇게 한 줄에 다 쓸 수도 있고, */ /* 이렇게 여러 줄에 걸쳐 작성할 수도 있습니다. */ 이런 주석들은 자바스크립트가 코드를 실행할 때 완전히 무시합니다.\n프로젝트 매직 8볼 만들기 사용자가 마음속으로 예/아니오 질문을 생각하고 버튼을 누르면, 앱이 랜덤으로 답변을 보여주는 간단한 프로그램입니다.\n먼저 HTML로 사용자 인터페이스를 만듭니다.\n\u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;예/아니오로 답할 수 있는 질문을 생각하세요!\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;button id=\u0026#34;answerButton\u0026#34;\u0026gt;결과 확인하기\u0026lt;/button\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;p id=\u0026#34;answerPlaceholder\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; 마지막 줄의 \u0026lt;p\u0026gt; 태그는 나중에 자바스크립트로 답변을 채워 넣을 빈 공간입니다.\n자바스크립트 코드의 핵심 부분은 다음과 같은데요.\nconst answers = [ // (A) \u0026#34;당연하죠\u0026#34;, \u0026#34;분명히 그렇게 될 겁니다\u0026#34;, \u0026#34;전적으로 동의합니다\u0026#34;, // 등등... ]; const answerButton = document.querySelector(\u0026#34;#answerButton\u0026#34;); const answerPlaceholder = document.querySelector(\u0026#34;#answerPlaceholder\u0026#34;); answerButton.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { // (B) const answerIndex = getRandomInteger(answers.length); const answer = answers[answerIndex]; answerPlaceholder.innerText = \u0026#34;답변: \u0026#34; + answer; }); A라인에서 시작하는 배열 리터럴은 여러 줄에 걸쳐 작성되었는데요.\n이렇게 코드를 여러 줄로 나누면 가독성이 좋아집니다.\nB라인에서는 버튼의 ‘click’ 이벤트에 반응하는 이벤트 리스너를 추가했는데요.\n이벤트 리스너는 먼저 answers 배열의 인덱스로 사용할 무작위 숫자를 하나 구합니다.\n그런 다음, 그 인덱스를 사용해 answers 배열에서 답변 하나를 꺼내오거든요.\n마지막으로, 꺼내온 답변을 answerPlaceholder 요소의 innerText로 설정해서 화면에 보여주게 됩니다.\ngetRandomInteger 함수는 어떻게 작동할까요 코드와 함께 원리를 차근차근 살펴보겠습니다.\n/* 0 \u0026lt;= i \u0026lt; max 범위의 무작위 정수 i를 반환합니다 */ const getRandomInteger = max =\u0026gt; { return Math.floor(Math.random() * max); }; 먼저 Math.random()은 0 이상 1 미만의 무작위 숫자를 만들어내거든요.\n즉, 0은 나올 수 있지만 1은 절대 나오지 않습니다.\n그다음 이 무작위 숫자에 max 값을 곱하는데요.\n무작위 숫자가 항상 1보다 작기 때문에, 곱한 결과 역시 항상 max보다 작을 수밖에 없습니다.\n마지막으로 Math.floor()를 사용해서 이 결과를 정수로 만드는데요.\nMath.floor()는 소수점 아래를 버리고 가장 가까운 정수로 ‘내림’하는 역할을 합니다.\n예를 들어 max가 5라고 가정하면, Math.random()이 0.999가 나오더라도 0.999 * 5는 4.995가 되고, Math.floor(4.995)의 최종 결과는 4가 되는 것이죠.\n결과적으로 이 함수는 0부터 max-1까지의 무작위 정수 중 하나를 안전하게 반환해 줍니다.\n","date":1758244071,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"44768678db81bcd22ea2341de980c3d8","permalink":"http://localhost:1313/posts/2025-09-19-learning-web-dev-part3-javascript-arrays/","publishdate":"2025-09-19T10:07:51+09:00","relpermalink":"/posts/2025-09-19-learning-web-dev-part3-javascript-arrays/","section":"posts","summary":"웹 개발 배우기 시리즈 3편입니다. 여러 데이터를 한 번에 관리하는 자바스크립트 배열의 개념과 사용법을 배우고, 매직 8볼 예제를 통해 실전 활용법을 익힙니다.","tags":["웹 개발 배우기","자바스크립트 기초","자바스크립트 배열","배열 사용법","매직 8볼","데이터 구조","코딩 시리즈"],"title":"웹 개발 배우기 3편 - 자바스크립트 배열 완전 정복, 여러 데이터를 한 번에 관리하기","type":"posts"},{"authors":null,"categories":null,"content":"웹 개발 배우기 2편 - 자바스크립트 문자열과 메소드, 드디어 첫 앱 만들기 ‘웹 개발 배우기’ 시리즈의 두 번째 시간이 돌아왔는데요.\n지난 1편에서는 자바스크립트의 숫자와 변수, 함수에 대해 알아봤습니다.\n이번 챕터에서는 텍스트, 즉 ‘문자열’을 다루는 방법과 함께 우리의 첫 번째 애플리케이션을 직접 만들어 볼 거거든요.\n텍스트를 위한 데이터 타입, 문자열 우리는 지금까지 숫자(8, 1.5 등)와 함수((x) =\u0026gt; {return x} 등)라는 두 가지 데이터 타입을 만나봤습니다.\n이제 또 다른 데이터 타입인 ‘문자열’에 대해 알아볼 차례인데요.\n문자열은 0개 이상의 문자(텍스트 기호)로 이루어진 텍스트를 의미합니다.\n문자열을 만들 때는 작은따옴표나 큰따옴표로 감싸주거든요.\n\u0026#34;이것도 문자열\u0026#34;; \u0026#34;이것 또한 문자열\u0026#34;; 물론 아무런 문자도 포함하지 않는 ‘빈 문자열’도 만들 수 있습니다.\n\u0026#34;\u0026#34;; \u0026#34;\u0026#34;; 여기서 흥미로운 점은 \u0026#39;abc\u0026#39;와 \u0026#34;abc\u0026#34;가 문법적으로는 다르지만 결국 같은 결과값을 만들어낸다는 점인데요.\n이건 우리가 이전에 봤던 숫자 123.0과 123이 문법은 달라도 결국 같은 값을 나타내는 것과 비슷한 원리입니다.\n문자열의 길이 \u0026gt; \u0026#39;\u0026#39;.length 0 \u0026gt; \u0026#39;abc\u0026#39;.length 3 이렇게 문자열의 길이를 쉽게 확인할 수 있습니다.\n문자열 연결하기 + 연산자 이걸 ‘문자열 연결’이라고 합니다.\n\u0026gt; let str = \u0026#39;\u0026#39;; \u0026gt; str = str + \u0026#39;만나서\u0026#39;; \u0026gt; str = str + \u0026#39; 반가워요.\u0026#39;; \u0026gt; str \u0026#39;만나서 반가워요.\u0026#39; 함수 역시 문자열을 반환할 수 있는데요.\nconst sayHello = name =\u0026gt; { return \u0026#34;안녕하세요 \u0026#34; + name + \u0026#34;님!\u0026#34;; }; 이 코드를 콘솔에 복사해서 붙여넣고 함수가 어떻게 작동하는지 시험해 볼 수 있습니다.\n\u0026gt; sayHello(\u0026#39;테리\u0026#39;) \u0026#39;안녕하세요 테리님!\u0026#39; 중첩된 변수 객체와 프로퍼티 이렇게 변수가 다른 변수를 담고 있는 구조를 ‘객체(object)‘라고 부릅니다.\n그리고 객체 안에 들어 있는 변수들은 그 객체의 ‘프로퍼티(property)‘라고 하거든요.\n예를 들어 자바스크립트에는 Math라는 미리 정의된 객체가 있고, 그 안에는 원주율 값을 가진 PI라는 프로퍼티가 있습니다.\n\u0026gt; Math.PI 3.141592653589793 이렇게 점(.)을 사용해서 객체 안의 프로퍼티에 접근할 수 있습니다.\n프로퍼티에 담긴 함수, 메소드 \u0026gt; Math.sqrt(9) 3 Math.sqrt는 숫자의 제곱근을 계산하는 함수를 담고 있는 프로퍼티인데요.\n이처럼 프로퍼티의 값이 함수일 경우, 특별히 ‘메소드(method)‘라고 부릅니다.\n어떤 메소드들은 자신이 속한 객체의 내용을 바탕으로 결과를 만들어내기도 하거든요.\n\u0026gt; \u0026#39;hello\u0026#39;.toUpperCase() \u0026#39;HELLO\u0026#39; toUpperCase 메소드는 ‘hello’라는 문자열 객체의 내용을 대문자로 바꿔주는 역할을 합니다.\n코딩을 위한 필수 도구, 텍스트 에디터 그래서 이 파일들을 만들고 수정하려면 ‘텍스트 에디터’가 필요합니다.\n특히 개발자들을 위해 전문화된 텍스트 에디터를 ‘IDE(통합 개발 환경)‘라고 부르는데요.\n웹 개발에 널리 쓰이는 인기 있는 IDE 두 가지를 소개해 드립니다.\n무료로 사용할 수 있는 ‘비주얼 스튜디오 코드(Visual Studio Code)‘와 개인 비상업용으로 무료인 ‘웹스톰(WebStorm)‘이 대표적입니다.\nIDE를 다운로드해서 설치한 뒤에, 제공되는 프로젝트 폴더를 열어 파일을 만들어보고 텍스트를 입력했다가 다시 지워보면서 사용법을 익혀보세요.\n프로젝트 log-hello.html 웹 앱이란 간단히 말해 ‘프로그램이 내장된 웹 페이지’라고 할 수 있습니다.\n아래 HTML 코드는 자바스크립트 코드를 포함하고 있는데요.\n\u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Log hello\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; const sayHello = name =\u0026gt; { return \u0026#34;Hello \u0026#34; + name + \u0026#34;!\u0026#34;; }; const message = sayHello(\u0026#34;Terry\u0026#34;); // `message`의 값을 콘솔에 기록합니다: console.log(message); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 여기서 \u0026lt;script\u0026gt; 태그 안에 있는 코드가 바로 자바스크립트 코드입니다.\n마지막 두 줄은 우리가 처음 보는 내용인데요.\n//로 시작하는 줄은 ‘주석’이라고 합니다.\n자바스크립트는 // 기호를 만나면 그 줄의 끝까지 모든 내용을 무시하는데요.\n덕분에 우리는 컴퓨터가 아닌 사람을 위해 코드에 대한 설명을 남길 수 있습니다.\n그리고 console.log(message);는 message라는 변수에 담긴 값을 콘솔에 출력하라는 명령어입니다.\n이 HTML 파일을 브라우저에서 열고 개발자 도구 콘솔을 확인하면 ‘Hello Terry!‘라는 메시지가 출력된 것을 볼 수 있을 겁니다.\n프로젝트 log-clicks.html 아래와 같이 id가 ’link’인 \u0026lt; a \u0026gt; 태그가 있다고 가정해 봅시다.\n\u0026lt;a id=\u0026#34;link\u0026#34; href=\u0026#34;\u0026#34;\u0026gt;Click here\u0026lt;/a\u0026gt; 그리고 이 링크가 클릭될 때마다 콘솔에 메시지를 찍어주는 자바스크립트 코드입니다.\nlet count = 1; const link = document.querySelector(\u0026#34;#link\u0026#34;); link.addEventListener(\u0026#34;click\u0026#34;, event =\u0026gt; { event.preventDefault(); // (A) console.log(\u0026#34;Click \u0026#34; + count); // (B) count = count + 1; }); 2번째 줄의 document.querySelector(\u0026#39;#link\u0026#39;)는 HTML 문서에서 id가 ’link’인 요소를 찾아오라는 뜻입니다.\n그리고 3번째 줄의 addEventListener는 ‘이벤트 리스너’를 추가하는 메소드인데요.\n‘click’ 이벤트가 발생할 때마다, 즉 사용자가 링크를 클릭할 때마다 두 번째 인자로 전달된 함수를 실행하라는 의미입니다.\nA라인의 event.preventDefault()는 링크를 클릭했을 때 페이지가 이동하는 기본 동작을 막아주는 역할을 하거든요.\n이렇게 하면 클릭할 때마다 콘솔에 ‘Click 1’, ‘Click 2’와 같이 숫자가 1씩 증가하며 기록되는 것을 볼 수 있습니다.\n숫자 123과 문자열 ‘123’의 차이 그렇다면 숫자 123과 문자열 \u0026#39;123\u0026#39;은 무슨 차이가 있을까요?\n123은 숫자라서 산술 연산을 할 수 있지만, \u0026#39;123\u0026#39;은 문자열이라 다른 문자열과 연결하는 등의 작업만 가능합니다.\n이 차이는 ‘강아지’와 ‘강아지 사진’의 차이와 비슷한데요.\n사진이 강아지처럼 보이긴 하지만, 우리가 사진을 데리고 산책을 할 수는 없는 것과 같습니다.\n마찬가지로 문자열 \u0026#39;123\u0026#39;은 숫자처럼 보이지만 숫자는 아닙니다.\n숫자와 문자열 변환하기 String() 함수는 숫자를 문자열로, Number() 함수는 문자열을 숫자로 바꿔줍니다.\n\u0026gt; String(123) \u0026#39;123\u0026#39; \u0026gt; Number(\u0026#39;123\u0026#39;) 123 또한 플러스(+) 연산자는 다른 한쪽이 문자열일 경우, 숫자를 자동으로 문자열로 변환해서 연결하거든요.\n\u0026gt; \u0026#39;구매한 사과 개수: \u0026#39; + 3 \u0026#39;구매한 사과 개수: 3\u0026#39; 이런 특징을 잘 알아두면 유용합니다.\n프로젝트 display-clicks.html 이제는 웹 페이지에 직접 정보를 표시해 볼 건데요.\n클릭 횟수를 보여줄 \u0026lt;span\u0026gt; 태그를 HTML에 추가하고, 자바스크립트 코드를 조금 수정해 보겠습니다.\n\u0026lt;div\u0026gt;클릭 횟수: \u0026lt;span id=\u0026#34;clickCount\u0026#34;\u0026gt;0\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt; const clickCountElement = document.querySelector(\u0026#34;#clickCount\u0026#34;); // (A) // ... 이벤트 리스너 내부 코드 ... clickCountElement.innerText = String(count); // (B) A라인에서 id가 ‘clickCount’인 \u0026lt;span\u0026gt; 요소를 가져왔습니다.\n그리고 B라인에서는 console.log 대신, count 값을 문자열로 변환해서 해당 요소의 .innerText 프로퍼티에 저장했는데요.\n이 .innerText는 HTML 요소의 텍스트 내용을 바꾸는 특별한 프로퍼티입니다.\n이제 링크를 클릭하면 콘솔이 아닌 웹 페이지의 숫자가 직접 바뀌는 것을 확인할 수 있습니다.\n프로젝트 temperature-converter.html 한쪽 입력 필드에 숫자를 입력하면 다른 쪽에 변환된 결과가 나타나는 방식입니다.\nHTML에는 id가 각각 ‘celsius’와 ‘fahrenheit’인 두 개의 \u0026lt;input\u0026gt; 필드가 있습니다.\nconst celsius = document.querySelector(\u0026#34;#celsius\u0026#34;); const fahrenheit = document.querySelector(\u0026#34;#fahrenheit\u0026#34;); const celsiusToFahrenheit = c =\u0026gt; { return c * (9 / 5) + 32; }; celsius.addEventListener(\u0026#34;change\u0026#34;, () =\u0026gt; { const c = Number(celsius.value); // (B) fahrenheit.value = String(celsiusToFahrenheit(c)); // (C) }); 이번에는 ‘change’라는 이벤트를 사용했는데요.\n이 이벤트는 입력 필드에 값을 입력하고 엔터를 치거나 다른 곳을 클릭했을 때 발생합니다.\n이벤트가 발생하면, B라인에서는 celsius 입력 필드의 내용(.value)을 문자열로 가져와 숫자로 변환합니다.\n그리고 C라인에서는 그 숫자를 화씨로 변환한 뒤, 다시 문자열로 바꿔 fahrenheit 입력 필드의 .value에 넣어주는 거죠.\n이렇게 입력 필드의 .value 프로퍼티는 값을 읽어올 수도, 값을 넣어 화면을 변경할 수도 있습니다.\n","date":1758243507,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"99c4b98497270ddf567084ac8e880689","permalink":"http://localhost:1313/posts/2025-09-19-learning-web-dev-part2-javascript-strings-methods/","publishdate":"2025-09-19T09:58:27+09:00","relpermalink":"/posts/2025-09-19-learning-web-dev-part2-javascript-strings-methods/","section":"posts","summary":"웹 개발 배우기 시리즈 2편입니다. 자바스크립트의 문자열과 메소드 개념을 배우고, 클릭 카운터와 온도 변환기 같은 간단한 웹 앱을 직접 만들어보며 이벤트 처리 방법을 익힙니다.","tags":["웹 개발 배우기","자바스크립트 기초","자바스크립트 문자열","자바스크립트 메소드","웹 앱 만들기","이벤트 리스너","DOM 조작"],"title":"웹 개발 배우기 2편 - 자바스크립트 문자열과 메소드, 드디어 첫 앱 만들기","type":"posts"},{"authors":null,"categories":null,"content":"웹 개발 배우기 1편 - 자바스크립트 첫걸음, 숫자와 변수 그리고 함수 완전 정복 이번 포스팅은 ‘웹 개발 배우기’ 시리즈의 일부인데요.\n프로그래밍 경험이 전혀 없는 분들을 위해 자바스크립트(JavaScript)로 웹 앱을 만드는 방법을 알려드리는 시리즈입니다.\n이번 챕터에서는 자바스크립트의 가장 첫걸음을 떼면서 숫자, 변수, 그리고 함수에 대해 알아볼 거거든요.\n다음 챕터부터는 실제로 유용한 앱을 만들면서 배우겠지만, 이번에는 간단한 상호작용을 통해 워밍업을 하는 시간이라고 생각하시면 됩니다.\n브라우저 콘솔 다행히도 모든 웹 브라우저에는 이 엔진이 내장되어 있습니다.\n우리가 이 엔진과 소통하는 여러 방법 중 하나가 바로 브라우저의 ‘콘솔’이거든요.\n이 콘솔이 어떻게 작동하는지는 곧 확인하게 될 겁니다.\n우선 지금 사용하고 계신 웹 브라우저의 콘솔을 여는 방법을 먼저 찾아보시는 게 첫 번째 단계인데요.\n보통 ‘크롬 개발자 도구’나 ‘파이어폭스 콘솔’처럼 검색하면 금방 찾으실 수 있습니다.\n참고로 앞으로 종종 이런 식으로 웹 검색을 통해 직접 무언가를 찾아보시라고 말씀드릴 때가 있을 텐데요.\n이건 웹 개발자에게 정말 중요한 역량입니다.\n항상 누군가 옆에서 하나하나 설명해 줄 수는 없거든요.\n스스로 자료를 찾고 실험하는 과정에 익숙해져야 합니다.\n콘솔은 어떻게 작동할까요 우리가 자바스크립트 코드를 ‘입력’하면, 웹 브라우저는 그에 대한 ‘출력’으로 결과를 보여주는 방식입니다.\n그럼 이제 직접 콘솔을 한번 사용해 볼까요.\n숫자 자바스크립트를 계산기처럼 써보기 쉽게 말해 숫자가 포함된 ‘계산식’이라고 생각하시면 됩니다.\n예를 들어, 자바스크립트는 이렇게 숫자를 더할 수 있거든요.\n// 우리가 입력한 내용 3 + 2; // 브라우저가 보여주는 결과 5; 여러분도 직접 브라우저 콘솔에 따라 입력해보면서 여기에 나오는 결과와 똑같이 나오는지 확인해보세요.\n이제부터 콘솔 상호작용은 아래와 같은 방식으로 표시할 건데요.\n\u0026gt; 3 + 2 5 첫 줄 시작 부분의 \u0026gt; (부등호)는 우리의 ‘입력’을 의미합니다.\n이건 브라우저가 표시해주는 기호이지 우리가 직접 입력하는 건 아니거든요.\n우리는 그 뒤에 오는 코드만 입력하면 되고, 다음 줄에 나오는 것이 바로 브라우저의 ‘출력’ 결과입니다.\n연산자와 피연산자 이때 연산자의 왼쪽과 오른쪽에 있는 값들을 ‘피연산자’라고 부릅니다.\n예를 들어 3 + 2에서 +는 연산자이고 3과 2는 피연산자인 것이죠.\n더 다양한 숫자 연산자 몇 가지 예를 보여드리겠습니다.\n뺄셈 연산자 - (하이픈)를 사용하면 숫자를 뺄 수 있거든요.\n\u0026gt; 3 - 2 1 곱셈 연산자 * (별표)는 숫자를 곱하는 데 사용됩니다.\n\u0026gt; 3 * 2 6 나눗셈 연산자 / (슬래시)를 쓰면 숫자를 나눌 수 있는데요.\n\u0026gt; 3 / 2 1.5 여기서 우리는 두 종류의 숫자를 보게 됩니다.\n하나는 5와 같은 ‘정수’이고, 다른 하나는 1.5와 같은 ‘부동 소수점’ 숫자인데요.\n‘부동 소수점 숫자’라는 건 간단히 말해 소수점을 가진 숫자라고 생각하시면 됩니다.\n사실 내부적으로 자바스크립트는 정수 5와 부동 소수점 숫자 5.0을 구분하지 않고 둘 다 그냥 ‘숫자’로 취급하거든요.\n궁금하시다면 위키피디아에서 더 많은 정보를 찾아볼 수 있습니다.\n더 긴 숫자 표현식 \u0026gt; 1 + 2 * 3 7 하지만 이렇게 여러 연산자가 함께 쓰이면 어떤 순서로 계산될지 바로 명확하게 보이지 않을 수 있습니다.\n그래서 저는 이런 경우 괄호를 사용해 계산 순서를 명확히 해주는 걸 선호하거든요.\n2 곱하기 3에 1을 더하는 경우입니다.\n\u0026gt; 1 + (2 * 3) 7 1 더하기 2에 3을 곱하는 경우인데요.\n\u0026gt; (1 + 2) * 3 9 자바스크립트는 첫 번째 방식, 즉 덧셈(과 뺄셈)보다 곱셈(과 나눗셈)을 먼저 계산하는 수학적 규칙을 따릅니다.\n자바스크립트 코드는 어떻게 실행될까요 우리는 엔진에 자바스크립트 ‘소스 코드’를 제공합니다.\n소스 코드는 항상 텍스트 형태이며, 엔진에게 무엇을 해야 할지 알려주는 명령어들을 담고 있거든요.\n엔진은 이 명령어들을 따라 내부적으로 작업을 수행하게 됩니다.\n보통 자바스크립트 엔진은 ‘블랙박스’와 같아서 우리는 그 안에서 무슨 일이 일어나는지 볼 수 없는데요.\n하지만 브라우저 콘솔처럼 명령어 실행 후 결과를 추출해서 보여주는 예외도 있습니다.\n자바스크립트 실행과 관련해서 알아두면 유용한 두 가지 용어가 있거든요.\n‘구문(Syntax)‘은 올바른 자바스크립트 프로그램을 작성하기 위한 규칙을 말합니다.\n‘런타임(Runtime)‘은 엔진이 자바스크립트 코드를 실행하고 있는 동안의 시간을 의미하는데요.\n이 두 가지는 앞으로 계속 듣게 될 용어입니다.\n변수 변수란 값을 담을 수 있는 ‘이름이 붙은 상자’라고 생각하시면 됩니다.\n\u0026gt; let myNumber = 8; undefined \u0026gt; myNumber * 2 16 첫 번째 줄에서 myNumber라는 변수를 만들었습니다.\nlet은 변수를 만드는 명령어 중 하나인데요.\nmyNumber는 우리가 만든 변수의 이름입니다.\n등호 =는 변수에 초기값을 지정하겠다는 의미거든요.\n여기서 8이 바로 그 초기값이고, 우리는 myNumber를 8로 ‘초기화’한 것입니다.\n세 번째 줄에서는 이 변수를 사용했는데요.\n이제 myNumber는 자신이 담고 있는 값 8을 대신하는 이름이 된 셈입니다.\n그런데 첫 번째 줄의 실행 결과로 나온 undefined는 무슨 의미일까요?\n이건 ‘실제 결과값이 없음’을 의미하는 일종의 가짜 값인데요.\n값을 만들어내는 표현식과 달리, 무언가를 실행하는 ‘문장’은 종종 별도의 결과값을 갖지 않습니다.\n변수 이름 규칙 그다음 글자부터는 첫 글자에 허용된 모든 문자와 함께 숫자(3, 0 등)도 사용할 수 있습니다.\n대부분의 변수 이름은 소문자로 시작하고, 단어가 바뀔 때 대문자를 사용하는 ‘카멜 케이스(camel case)’ 방식을 따르거든요.\n예를 들면 numberOfPeople 이나 value3 같은 식입니다.\n반면 값이 절대 변하지 않는 변수의 이름은 가끔 모든 글자를 대문자로, 단어 사이는 밑줄로 구분해서 짓기도 하는데요.\nNUMBER_OF_PEOPLE 처럼 말이죠.\n문장의 결과는 거의 중요하지 않아요 그래서 앞으로는 세미콜론으로 끝나는 콘솔 입력의 결과값(undefined)은 생략하고 보여드리겠습니다.\n\u0026gt; let myNumber = 8; \u0026gt; myNumber * 2 16 구문 오류 예를 들어 숫자로 시작하는 잘못된 변수 이름을 사용해 보겠습니다.\n\u0026gt; let 1number = 7; SyntaxError: Invalid or unexpected token 정확한 메시지는 자바스크립트 엔진마다 조금씩 다를 수 있지만, 오류의 이름은 항상 SyntaxError입니다.\n변수에 값 할당하기 \u0026gt; let value = 0; \u0026gt; value 0 \u0026gt; value = 3; \u0026gt; value 3 처음에는 value라는 변수를 0으로 초기화했지만, 나중에 그 값을 3으로 변경했습니다.\n이때 let 없이 할당 연산자 =를 사용했거든요.\n할당 연산자의 오른쪽에는 어떤 표현식이든 올 수 있습니다.\n\u0026gt; value = 1 + 1 + 1; \u0026gt; value 3 이 때문에 수학적으로는 이상해 보이는 이런 문장도 가능한데요.\n\u0026gt; let myVar = 0; \u0026gt; myVar = myVar + 1; \u0026gt; myVar 1 myVar = myVar + 1; 이 문장은 myVar의 현재 값을 가져와서 1을 더한 다음, 그 결과를 다시 myVar에 저장하라는 의미입니다.\n즉, 할당 연산자는 수학의 등호와는 다르다고 생각해야 합니다.\n상수 (변경 불가능한 변수) 이렇게 하면 실수로 값을 바꾸려고 할 때 자바스크립트가 경고를 해줍니다.\n\u0026gt; const TWO = 2; \u0026gt; TWO + TWO 4 \u0026gt; TWO = 3; TypeError: Assignment to constant variable. const는 ‘이 변수는 절대 바뀌지 않을 것’이라는 개발자를 위한 힌트로 사용하는 것이 더 유용한데요.\n이렇게 선언된 변수는 ‘상수’라고 부릅니다.\n함수 이제 ‘함수’라는 또 다른 종류의 값을 살펴볼 차례입니다.\n함수란 변수 안에 저장해두고 사용하는 ‘작은 프로그램’과 같거든요.\n우리는 함수를 ‘호출’해서 실행시킬 수 있습니다.\n함수는 0개 이상의 입력값을 받아서 하나의 결과값을 만들어내는데요.\n아래 예제에서 timesThree라는 변수가 바로 함수입니다.\n\u0026gt; const timesThree = (x) =\u0026gt; { return x * 3; }; \u0026gt; timesThree(2) 6 \u0026gt; timesThree(0.5) 1.5 첫 번째 줄에서 timesThree라는 함수를 만들었고, 두 번째 줄에서는 2라는 값을 넣어 함수를 호출했습니다.\n그러자 6이라는 결과가 반환되었죠.\n(x): 함수의 ‘입력값’이 x라는 변수에 저장되는데요.\n이 변수를 함수의 ‘매개변수(parameter)‘라고 부릅니다.\n=\u0026gt; { return x * 3; }: 화살표 뒤 중괄호 안에는 함수의 실제 코드가 들어가는데요.\nreturn 문은 함수 호출의 결과를 지정하는 역할을 합니다.\n이렇게 함수를 만드는 문법을 ‘화살표 함수’라고 부릅니다.\n매개변수 vs 인자 자바스크립트는 대부분 줄 바꿈을 무시하기 때문에, 사람이 읽기 쉽게 코드를 여러 줄로 나눠 쓸 수 있습니다.\nconst add = (x, y) =\u0026gt; { // (A) return x + y; }; const result = add(2, 3); // (B) // `result`는 5가 됩니다. 사실 ‘매개변수(parameter)‘와 ‘인자(argument)‘라는 용어는 종종 혼용되기도 하는데요.\n하지만 명확하게 구분해서 알아두는 것이 좋습니다.\n위 예시에서 x와 y는 add 함수의 ‘매개변수’이구요.\n함수를 호출할 때 전달한 2와 3이 바로 ‘인자’입니다.\n예제 섭씨를 화씨로 변환하기 const celsiusToFahrenheit = c =\u0026gt; { const f = c * (9 / 5) + 32; return f; }; 매개변수 c는 섭씨 온도를 나타내는 숫자 입력값입니다.\n우리는 그 값을 화씨로 변환해서 상수 f에 저장하고, 최종적으로 f를 함수의 결과로 반환합니다.\n이 코드를 콘솔에 붙여넣고 함수를 호출해 볼 수 있거든요.\n\u0026gt; …","date":1758242623,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"6a649125184e3907e1dae095bb9c079a","permalink":"http://localhost:1313/posts/2025-09-19-learning-web-dev-part1-javascript-basics-numbers-variables-functions/","publishdate":"2025-09-19T09:43:43+09:00","relpermalink":"/posts/2025-09-19-learning-web-dev-part1-javascript-basics-numbers-variables-functions/","section":"posts","summary":"웹 개발을 처음 시작하는 분들을 위해 자바스크립트의 가장 기본 개념인 숫자, 변수, 함수 사용법을 쉽고 자세하게 설명합니다. 브라우저 콘솔을 활용한 실습으로 프로그래밍의 기초를 다져보세요.","tags":["자바스크립트 기초","웹 개발 배우기","웹 개발 입문","자바스크립트 변수","자바스크립트 함수","프로그래밍 초보","코딩 배우기","브라우저 콘솔"],"title":"웹 개발 배우기 1편 - 자바스크립트 첫걸음, 숫자와 변수 그리고 함수 완전 정복","type":"posts"},{"authors":null,"categories":null,"content":"리액트를 배우셨군요 유감입니다 4편 (테스트, 생태계, 그리고 체념의 미학) 1편부터 3편까지 리액트의 탄생 비화부터 JSX, 컴포넌트, 상태 관리, 그리고 useEffect의 함정까지 정말 뼈를 때리는 내용들이었죠.\n오늘은 드디어 이 대장정의 마지막 편입니다.\n리액트 개발자들의 정신 건강을 위협하는 ‘테스트’의 세계, 선택 장애를 유발하는 거대한 ‘생태계’, 그리고 이 모든 고통 끝에 찾아오는 ‘체념의 미학’에 대해 이 책이 어떤 이야기를 들려주는지 함께 보시죠.\n리액트 테스트, 컴포넌트를 위한 심리치료 리액트 애플리케이션을 테스트하는 건 마치 태풍 속에서 카드로 집을 짓는 것과 같다고 하더라고요.\n우리는 코드를 테스트하는 게 아니라, 코드가 DOM 요소가 될지도 모르는 무언가를 표현한 것을 리액트가 추상화한 것을 테스트하는 셈이죠.\n이 문장이 복잡하게 들리신다면, 실제 테스트 코드를 보면 기절하실지도 모릅니다.\n단 5줄짜리 간단한 컴포넌트를 테스트하기 위해, 우리는 50줄이 넘는 코드로 그 컴포넌트가 만지는 모든 것을 모킹(mocking)해야 하거든요.\n// 5줄짜리 컴포넌트 const UserGreeting = ({ userId }) =\u0026gt; { const user = useUser(userId); return \u0026lt;div\u0026gt;Hello, {user?.name}!\u0026lt;/div\u0026gt;; }; // 50줄짜리 테스트 코드 import { render, screen, waitFor } from \u0026#34;@testing-library/react\u0026#34;; // ... 수많은 라이브러리 import jest.mock(\u0026#34;../hooks/useUser\u0026#34;, () =\u0026gt; ({ useUser: jest.fn(), })); describe(\u0026#34;UserGreeting\u0026#34;, () =\u0026gt; { // ... 수많은 사전 설정 코드 it(\u0026#34;displays user name\u0026#34;, async () =\u0026gt; { useUser.mockReturnValue({ name: \u0026#34;John\u0026#34; }); render( \u0026lt;QueryClientProvider client={queryClient}\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;MemoryRouter\u0026gt; \u0026lt;ThemeProvider theme={theme}\u0026gt; \u0026lt;UserGreeting userId={1} /\u0026gt; \u0026lt;/ThemeProvider\u0026gt; \u0026lt;/MemoryRouter\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/QueryClientProvider\u0026gt; ); await waitFor(() =\u0026gt; { expect(screen.getByText(\u0026#34;Hello, John!\u0026#34;)).toBeInTheDocument(); }); }); }); 5줄을 테스트하기 위해 50줄을 작성하는 것, 이것이 바로 진보입니다.\nReact Testing Library의 위선 ‘React Testing Library’의 철학은 “사용자가 사용하는 것처럼 컴포넌트를 테스트하라!“인데요.\n현실은 좀 다르죠.\n사용자는 버튼을 클릭하고 텍스트를 읽을 뿐, querySelector가 뭔지 알 턱이 없습니다.\n이 라이브러리의 슬로건은 “자바스크립트와 DOM API를 알고 소스 코드에 접근할 수 있는 사용자가 사용하는 것처럼 테스트하라!“가 더 정확할 거예요.\n게다가 테스트를 실행할 때마다 우리를 괴롭히는 act(...) 경고는 또 어떤가요.\n분명히 라이브러리 함수 안에 act가 포함되어 있다고 했는데도, 우리는 여전히 이 경고를 마주하고 act로 코드를 감싸야만 합니다.\n리액트 테스팅의 세계에 오신 것을 환영합니다.\n여기서는 규칙은 그때그때 만들어지고 경고는 별로 중요하지 않죠.\n스냅샷 테스트, 거짓말하는 거짓말 탐지기 스냅샷 테스트는 테스트를 쉽게 만들어 줄 구원투수처럼 보였는데요.\n컴포넌트의 렌더링 결과를 파일로 저장해두고, 다음 테스트에서 변경 사항이 있는지 비교하는 방식이죠.\n하지만 실제로 일어나는 일은 이렇습니다.\n테스트가 실패한다.\n“컴포넌트가 바뀐 건가? 잘 모르겠는데?”\nnpm test -- -u 명령어로 모든 스냅샷을 업데이트한다.\n모든 테스트가 통과한다.\n배포한다.\n전혀 도움이 되지는 않지만, 기분은 좋게 만들어주죠.\n생태계, 똑같은 것을 만드는 47가지 방법 리액트 생태계는 마치 모든 요리가 스파게티인 뷔페와 같거든요.\n면발이 서로 다르게 엉켜있을 뿐이죠.\n모든 결정에 대해 47가지의 선택지가 주어지고, 각각이 ‘최고의 방법’이라고 주장하는데요.\n하나를 고르고 나면 세 개의 새로운 선택지가 나타나고 당신이 고른 것은 이미 구식이 되어 있습니다.\n프레임워크부터 CSS, 폼까지 리액트 프로젝트를 시작하는 것부터가 전쟁인데요.\n한때 표준이었던 ‘Create React App’은 이제 공식적으로 버려졌고, 그 자리를 ‘Next.js’, ‘Vite’, ‘Remix’ 같은 프레임워크들이 차지했습니다.\n단순한 블로그를 만드는데 분산 시스템에 대한 이해가 필요하게 된 셈이죠.\nCSS를 작성하는 방식도 마찬가지인데요.\n‘styled-components’, ‘Emotion’, ‘CSS Modules’, ‘Tailwind’ 등 수많은 방법론이 서로 자기가 최고라고 외치고 있습니다.\n당신의 CSS는 이제 CSS를 생성하는 자바스크립트가 되었죠.\nHTML 폼이 너무 단순했나요?\n걱정 마세요.\n‘React Hook Form’, ‘Formik’ 같은 라이브러리들이 당신을 위해 준비되어 있습니다.\n단순했던 \u0026lt;form\u0026gt; 태그는 이제 수십 줄의 코드와 유효성 검사 스키마, 그리고 복잡한 상태 관리 로직으로 대체되었죠.\nnpm audit이라는 보안 연극 npm install을 실행할 때마다 마주치는 수백, 수천 개의 취약점 경고는 또 어떤가요.\n$ npm install found 1,746 vulnerabilities (1,698 low, 47 moderate, 1 high) run `npm audit fix` to fix them $ npm audit fix fixed 0 of 1,746 vulnerabilities 1,746 vulnerabilities remain 이것이야말로 보안 연극의 정수입니다.\n대부분의 ‘취약점’은 개발용 의존성의 정규식 DoS 공격 가능성이거나, 당신이 전혀 사용하지 않는 패키지의 프로토타입 오염 같은 것들이죠.\n하지만 저 빨간색 경고 메시지는 정말 사람을 불안하게 만듭니다.\n옆집 잔디는 항상 푸르다? (그리고 다시 리액트로 돌아오는 이유) 모든 리액트 개발자는 “분명 더 나은 방법이 있을 거야\u0026#34;라고 생각하는 시기를 겪게 되는데요.\n맞습니다.\n더 나은 방법은 존재하죠.\n하지만 당신은 아마 결국 리액트를 다시 쓰게 될 겁니다.\n채용 시장이 그렇게 말하고 있으니까요.\n‘Vue’는 리액트와 앵귤러의 장점을 합친 합리적인 프레임워크이고요.\n‘Svelte’는 가상돔도 런타임도 없는 혁신적인 컴파일러입니다.\n‘SolidJS’는 리액트처럼 생겼지만 훨씬 빠르죠.\n‘HTMX’는 자바스크립트 없이 서버가 내려준 HTML만으로 인터랙션을 구현하는, 웹의 근본으로 돌아가자는 혁명적인 아이디어입니다.\n이 모든 대안들은 각자의 방식으로 리액트보다 뛰어나거나 단순한데요.\n하지만 우리는 결국 리액트로 돌아옵니다.\n왜냐하면 95%의 채용 공고가 리액트를 요구하고, 가장 큰 생태계와 커뮤니티를 가지고 있으며, 이미 우리는 리액트라는 납치범을 사랑하게 되는 ‘스톡홀름 증후군’에 걸렸기 때문이죠.\n체념, 리액트와 평화롭게 공존하는 법 부정, 분노, 타협, 우울을 거쳐 드디어 우리는 ‘수용’의 단계에 이르렀습니다.\n이것은 패배나 항복이 아니라, 현실을 받아들이고 그 안에서 평화를 찾는 지혜죠.\n리액트와 함께 제정신을 유지하는 첫걸음은 바로 ‘싸울 전투를 고르는 것’인데요.\n빌드 시스템이나 완벽한 컴포넌트 구조 같은 것들과 싸우는 대신, ‘번들 사이즈’나 ‘불필요한 리렌더링’처럼 실제로 사용자 경험에 영향을 미치는 문제들과 싸워야 합니다.\n그리고 모든 문제에 리덕스를 적용하려 들지 말고, 가장 단순한 해결책(useState)부터 시작해서, 고통이 정말 심해질 때만 더 복잡한 도구를 꺼내 들어야 하죠.\n리액트의 모든 기능이 나쁜 것은 아닙니다.\n‘컴포넌트 구성’이나 ‘선언적 렌더링’ 같은 개념은 분명히 복잡한 UI를 조직화하는 데 도움이 되고요.\nNext.js나 React Query 같은 생태계의 도구들을 현명하게 사용하면 생산성을 크게 높일 수 있죠.\n마치며 당신은 리액트 개발자가 되었다, 유감이지만 축하합니다.\n당신은 마침내 리액트를 배우셨습니다.\n이제 당신은 컴포넌트, 상태, props, 훅, 그리고 이 모든 것들이 만들어내는 실존적 공포를 이해하게 되었죠.\n당신은 이제 리액트 개발자입니다.\n심심한 위로의 말씀을 전합니다.\n리액트는 완벽하지 않습니다.\n심지어 좋다고 말하기도 어렵죠.\n하지만 어디에나 있고, 일자리를 구하게 해주며, 거대한 생태계의 지원을 받습니다.\n당신은 리액트를 사랑할 필요도, 옹호할 필요도 없습니다.\n그저 생산적으로 사용하고, 제품을 출시하고, 퇴근하면 그만이죠.\n결국 이기는 사람은 아무도 없습니다.\n우리 모두 이 부조리한 산업 속에서 최선을 다하고 있을 뿐이죠.\n이제 가서 무언가를 만드세요.\n그리고 node_modules 폴더에 대해서는 되도록 생각하지 마시고요.\n괜찮습니다.\n모든 게 다 괜찮을 거예요.\n하하하!\n","date":1755931892,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"4d8212c7b7e83879528c421412672173","permalink":"http://localhost:1313/posts/2025-08-23-react-a-satirical-guide-part-4-testing-ecosystem-acceptance/","publishdate":"2025-08-23T15:51:32+09:00","relpermalink":"/posts/2025-08-23-react-a-satirical-guide-part-4-testing-ecosystem-acceptance/","section":"posts","summary":"리액트 테스트는 왜 고통스러울까요? 수많은 라이브러리로 이루어진 생태계 속에서 우리는 어떻게 길을 잃게 될까요? 어느 냉소적인 개발자의 리액트 입문서, 그 마지막 여정에서 우리는 마침내 체념과 평화를 얻게 됩니다.","tags":["리액트","React","리액트 테스트","리액트 생태계","프론트엔드","개발자 유머"],"title":"리액트를 배우셨군요 유감입니다 4편 (테스트, 생태계, 그리고 체념의 미학)","type":"posts"},{"authors":null,"categories":null,"content":"리액트를 배우셨군요 유감입니다 3편 (useEffect와 Props Drilling이라는 지옥도) 1편에서는 리액트의 탄생 비화와 ‘자바스크립트 피로감’에 대해, 2편에서는 ‘JSX’와 ‘컴포넌트’라는 리액트의 기묘한 철학에 대해 알아봤습니다.\n오늘은 드디어 이 고통의 핵심으로 더 깊이 들어가 보려고 합니다.\n바로 리액트 개발자라면 누구나 한 번쯤 머리를 쥐어뜯게 만들었던 ‘useEffect’, 그리고 데이터 흐름을 고통스럽게 만드는 ‘Props Drilling’에 대해 이 글에서 얼마나 통렬하게 꼬집는지 함께 보시죠.\nuseEffect 스스로를 쏘기 위해 만들어진 총 useEffect는 “함수형 컴포넌트에서 사이드 이펙트는 어떻게 처리하죠?“라는 질문에 대한 리액트의 대답인데요.\n하지만 저자의 말에 따르면, 그 대답은 “버그와 함께, 혼란스러운 방식으로, 개발자의 정신을 피폐하게 만든다\u0026#34;입니다.\n만약 리액트 훅들을 하나의 가족에 비유한다면, useEffect는 착한 마음을 가졌지만 계속해서 집에 불을 지르는 말썽쟁이 십대와 같다고 하더라고요.\ncomponentDidMount의 사악한 쌍둥이 과거 클래스 컴포넌트 시절에는 우리에게 아주 명확한 생명주기 메소드들이 있었죠.\ncomponentDidMount는 컴포넌트가 마운트될 때 딱 한 번, componentDidUpdate는 props가 바뀔 때, componentWillUnmount는 컴포넌트가 사라지기 직전에 실행되었습니다.\n아주 명확하고 예측 가능했죠.\n리액트는 이 명확함을 보고 “이 모든 걸 하나의 혼란스러운 함수로 합쳐보면 어떨까?“라고 생각한 게 틀림없습니다.\nconst NewComponent = ({ id }) =\u0026gt; { useEffect(() =\u0026gt; { console.log(\u0026#34;마운트된 건가? 업데이트된 건가? 둘 다인가? 누가 알겠어!\u0026#34;); return () =\u0026gt; { console.log(\u0026#34;클린업! 언마운트인가? 둘 다인가? 미스터리!\u0026#34;); }; }, [id]); // id가 바뀔 때... 아니면 마운트될 때... 아니면... }; 이 모든 혼란의 중심에는 바로 ‘의존성 배열’이라는 녀석이 있습니다.\n파멸의 의존성 배열 useEffect의 두 번째 인자인 의존성 배열은 이펙트가 언제 실행될지를 결정하는데요.\n간단해 보이지만, 온갖 함정으로 가득 차 있죠.\n_ 배열이 없으면 모든 렌더링 후에 실행됩니다.\n보통은 버그로 이어지죠.\n_ 빈 배열([])을 넣으면 마운트 시 한 번만 실행됩니다.\n(하지만 StrictMode에서는 두 번 실행되는 거짓말쟁이죠!)\n* 배열 안에 값을 넣으면, 그 값이 바뀔 때마다 실행됩니다.\n(하지만 객체나 함수를 넣으면 참조가 매번 바뀌어서 항상 실행될 수도 있죠!)\n그리고 이 의존성 배열은 우리에게 ‘무한 루프’라는 선물을 주기도 하는데요.\nconst InfiniteLoop = () =\u0026gt; { const [count, setCount] = useState(0); // count가 바뀔 때마다 실행되는데, 실행될 때마다 count를 바꿈 useEffect(() =\u0026gt; { setCount(count + 1); }, [count]); return \u0026lt;div\u0026gt;{count}\u0026lt;/div\u0026gt;; }; 이 코드를 실행하면 당신의 브라우저는 비명을 지르며 멈출 겁니다.\n“CPU 사용량이 왜 100%죠?” 라고 묻는다면, “useEffect 때문입니다” 라고 답하면 됩니다.\n데이터 페칭이라는 대참사 모든 리액트 입문자가 처음으로 useEffect를 사용해 데이터를 가져오려고 시도하는 코드는 보통 이렇습니다.\nuseEffect(() =\u0026gt; { fetch(`/api/users/${userId}`) .then(res =\u0026gt; res.json()) .then(data =\u0026gt; setUser(data)); }, [userId]); 깔끔해 보이지만, 이 코드에는 로딩 상태도, 에러 처리도, 경쟁 상태(Race Condition) 방지도, 심지어 데이터를 가져오는 중에 컴포넌트가 언마운트되는 경우에 대한 처리도 전혀 없습니다.\n이 모든 것을 제대로 처리하려면 코드는 30줄이 넘는 괴물이 되어버리죠.\n그러면 사람들은 말합니다.\n“그냥 React Query 쓰세요.”\n결국 리액트가 만든 문제를 해결하기 위해 또 다른 라이브러리를 도입하게 되는 겁니다.\nProps Drilling 끝없이 내려가는 데이터 Props Drilling은 당신의 증조할머니가 당신에게 가보를 물려주고 싶은데, 직접 주는 대신 할머니에게 주고, 할머니는 어머니에게, 어머니는 당신에게 주는 것과 같은데요.\n문제는 할머니와 어머니는 그 가보에 전혀 관심이 없다는 점이죠.\n그들은 그저 이 세대 간의 ‘폭탄 돌리기’ 게임에서 중간 전달자일 뿐입니다.\n이것이 바로 리액트의 데이터 흐름이죠.\n‘단방향’이라는 말은 ‘불편하다’는 말을 있어 보이게 표현한 것뿐입니다.\n소품들의 크리스마스 트리 리액트에서 데이터는 이런 식으로 흐르는데요.\nconst App = () =\u0026gt; { const [user, setUser] = useState({ name: \u0026#34;John\u0026#34; }); return \u0026lt;Dashboard user={user} setUser={setUser} /\u0026gt;; }; const Dashboard = ({ user, setUser }) =\u0026gt; { return \u0026lt;Profile user={user} setUser={setUser} /\u0026gt;; }; // ...중간 컴포넌트 생략... const NameEditor = ({ user, setUser }) =\u0026gt; { // 드디어 이 props를 사용! return ( \u0026lt;input value={user.name} onChange={e =\u0026gt; setUser({ ...user, name: e.target.value })} /\u0026gt; ); }; 6개의 컴포넌트 중 5개는 user나 setUser에 전혀 관심이 없지만, 리액트가 시켰기 때문에 모두 이 props를 받아서 아래로 전달해야만 합니다.\n이것의 진짜 문제는 코드가 길어지는 것보다도 ‘결합도(coupling)‘가 높아진다는 점인데요.\n중간에 있는 모든 컴포넌트가 자기가 쓰지도 않는 props에 의존하게 되면서, 이제는 그저 우체부 역할을 하는 컴포넌트가 되어버립니다.\nContext API라는 구원투수 (인 척하는 것) 리액트도 이 문제를 모르는 건 아니어서 ‘Context API’라는 해결책을 내놓았는데요.\nconst UserContext = createContext(); const App = () =\u0026gt; { const [user, setUser] = useState({ name: \u0026#34;John\u0026#34; }); return ( \u0026lt;UserContext.Provider value={{ user, setUser }}\u0026gt; \u0026lt;Dashboard /\u0026gt; \u0026lt;/UserContext.Provider\u0026gt; ); }; const NameEditor = () =\u0026gt; { const { user, setUser } = useContext(UserContext); // ... }; 이제 중간 컴포넌트들을 건너뛰고 데이터를 바로 주입할 수 있게 되었습니다.\n문제가 해결된 것 같죠?\n대신 우리는 ‘보이지 않는 의존성’, ‘Context가 바뀔 때마다 발생하는 무수한 리렌더링’, 그리고 앱 최상단을 뒤덮는 ‘프로바이더 지옥’이라는 새로운 문제를 얻게 되었습니다.\nProps Drilling을 해결하려다 ‘Context 혼란’이라는 더 큰 문제를 만들어낸 셈이죠.\n패턴과 안티패턴 그 좋고, 나쁘고, 이상한 것 리액트의 패턴들은 마치 패션 트렌드와 같은데요.\n오늘 최고라고 칭송받던 것이 내일은 코드 스멜이 되고, 작년의 안티패턴이 올해의 베스트 프랙티스가 되기도 하죠.\n‘컨테이너/프레젠테이셔널’ 패턴을 기억하시나요?\n데이터 로직을 다루는 ‘스마트’ 컨테이너 컴포넌트와, 오직 화면만 그리는 ‘멍청한’ 프레젠테이셔널 컴포넌트로 나누는 것이 한때는 황금률이었습니다.\n하지만 훅이 등장하면서, 이제는 그냥 하나의 컴포넌트 안에서 데이터도 가져오고 화면도 그리는 것이 일반적이 되었죠.\n몇 년간 우리가 맹세했던 그 패턴은 하루아침에 “왜 굳이 컴포넌트를 두 개로 나누죠?“라는 비아냥을 듣는 안티패턴이 되어버렸습니다.\nHOC(Higher-Order Components), Render Props 같은 패턴들도 한 시대를 풍미했지만, 이제는 커스텀 훅에 자리를 내주고 복잡성의 상징처럼 여겨지게 되었죠.\n성능 우리가 스스로에게 하는 거짓말들 “리액트는 빠르다!” 와 “리액트는 느리다!“는 주장이 항상 팽팽하게 맞서는데요.\n진실은, 리액트는 당신이 허락하는 만큼만 빠르다는 겁니다.\n그리고 보통 우리는 리액트가 빨라지는 것을 잘 허락하지 않죠.\n리액트 성능에 대한 신화들 신화 1 “가상돔은 리액트를 빠르게 만든다”\n이건 거짓말입니다. 가상돔은 리액트를 ‘가능하게’ 만드는 것이지, ‘빠르게’ 만드는 것이 아니죠.\n바닐라 자바스크립트로 직접 DOM을 조작하는 것이 거의 항상 더 빠릅니다.\n가상돔은 성능 향상이 아니라 오버헤드죠.\n신화 2 “리액트는 바뀐 부분만 업데이트한다” 기술적으로는 사실이지만, 실제로는 거짓에 가깝습니다. 부모 컴포넌트의 상태가 바뀌면, 그 아래의 모든 자식 컴포넌트 함수들이 ‘전부’ 다시 실행됩니다.\n리액트는 이 함수들을 모두 실행해본 뒤에야 가상돔을 비교해서 실제돔에 무엇을 바꿀지 결정하거든요.\n이런 불필요한 리렌더링을 막기 위해 우리는 React.memo를 사용하는데요.\n이건 리액트가 스스로 “불필요한 리렌더링이 문제라는 것을 인정합니다\u0026#34;라고 말하는 것과 같죠.\n하지만 React.memo조차도 props로 객체나 함수를 내려주면 속수무책으로 깨져버립니다.\n그래서 우리는 useMemo와 useCallback을 쓰게 되죠.\n성능 문제가 있지도 않은데 미리 최적화하겠다며 코드를 더 복잡하게 만드는 ‘섣부른 최적화의 중심지’에 오신 것을 환영합니다.\n마치며 useEffect는 선언적인 패러다임에 명령형 작업을 억지로 끼워 넣으려고 할 때 어떤 일이 벌어지는지를 보여주는 대표적인 사례입니다.\nProps Drilling은 단방향 데이터 흐름이라는 원칙을 너무 고집할 때 얼마나 고통스러운지를 보여주죠.\n그리고 수많은 패턴과 성능 최적화 기법들은, …","date":1755931550,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"49d6db864c9f5b9c783cb29a43a3ec66","permalink":"http://localhost:1313/posts/2025-08-23-react-a-satirical-guide-part-3-useeffect-props-hell/","publishdate":"2025-08-23T15:45:50+09:00","relpermalink":"/posts/2025-08-23-react-a-satirical-guide-part-3-useeffect-props-hell/","section":"posts","summary":"리액트의 useEffect가 왜 버그의 온상인지, Props Drilling이 왜 고통스러운지, 그리고 우리가 믿고 있던 성능 최적화 패턴의 배신에 대해 신랄하게 파헤칩니다. 어느 냉소적인 개발자의 리액트 입문서, 그 세 번째 이야기.","tags":["리액트","React","useEffect","Props Drilling","리액트 패턴","리액트 성능"],"title":"리액트를 배우셨군요 유감입니다 3편 (useEffect와 Props Drilling이라는 지옥도)","type":"posts"},{"authors":null,"categories":null,"content":"리액트를 배우셨군요 유감입니다 2편 (JSX와 컴포넌트, 아무도 원치 않았던 그 아이) 1편에서는 리액트가 대체 왜 태어났는지, 그리고 우리 모두를 지치게 만드는 ‘자바스크립트 피로감’의 역사에 대해 알아봤죠.\n오늘은 리액트의 가장 눈에 띄는 특징이자 가장 논란이 많은 두 가지, 바로 ‘JSX’와 ‘컴포넌트’에 대해 이 책이 얼마나 신랄하게 비판하는지 함께 들여다보려고 합니다.\n리액트 개발자들은 “이건 그냥 자바스크립트야!“라고 외치지만, 나머지 우리들은 “이게 어딜 봐서 자바스크립트야?“라고 되묻게 만드는 바로 그 지점이죠.\nJSX 아무도 원치 않았던 그 아이 JSX는 리액트의 가장 대표적인 기능이면서 동시에 가장 큰 논란거리이기도 한데요.\n마치 HTML을 쓰는 건지 자바스크립트를 쓰는 건지 결정하지 못해서, 둘 다를 동시에 어설프게 쓰는 것과 같은 모습이죠.\n리액트 공식 문서에 따르면 JSX는 ‘자바스크립트에 대한 구문 확장’이라고 하는데요.\n이건 마치 오리너구리를 보고 “오리에 대한 포유류 확장\u0026#34;이라고 말하는 것과 같습니다.\n기술적으로는 사실일지 몰라도, 듣는 사람을 아주 심란하게 만들죠.\n트랜스파일이라는 세금 JSX의 가장 큰 비밀은 바로 브라우저가 이걸 전혀 이해하지 못한다는 건데요.\n우리가 작성한 아름다운 JSX 코드는 실행되기 전에 반드시 일반 자바스크립트로 변환되어야만 합니다.\n// 우리가 작성하는 코드 \u0026lt;div className=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Hello, {name}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt;; // 실제로 브라우저에서 실행되는 코드 React.createElement( \u0026#34;div\u0026#34;, { className: \u0026#34;hello\u0026#34; }, React.createElement(\u0026#34;h1\u0026#34;, null, \u0026#34;Hello, \u0026#34;, name) ); 우리가 작성하는 모든 태그 하나하나가 결국 React.createElement라는 함수 호출로 바뀌는 겁니다.\n이 말인즉슨, 우리는 Babel 같은 트랜스파일러가 필요하고, 빌드 과정이 필요하며, Webpack이나 Vite 같은 빌드 도구 설정이 필요하다는 뜻이죠.\n단지 자바스크립트 안에서 HTML 비슷한 문법을 쓰기 위해서 말입니다.\n온갖 이상한 규칙들 “JSX는 HTML과 거의 똑같아!“라고 리액트 개발자들은 말하지만, 실상은 전혀 다른데요.\nclass는 className이 되고, for는 htmlFor가 됩니다.\nstyle 속성은 더 이상 문자열이 아니라, 카멜케이스로 된 속성명을 가진 자바스크립트 객체여야 하죠.\n// HTML 스타일 \u0026lt;div style=\u0026#34;color: red; font-size: 16px;\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt; // JSX 스타일 \u0026lt;div style={{ color: \u0026#39;red\u0026#39;, fontSize: \u0026#39;16px\u0026#39; }}\u0026gt;Hello\u0026lt;/div\u0026gt; 저 중괄호 두 개는 오타가 아닙니다.\n바깥쪽 중괄호는 “이제부터 자바스크립트 시작!“이라는 뜻이고, 안쪽 중괄호는 객체를 정의하는 문법이죠.\n게다가 font-size가 fontSize로 바뀐 것처럼, 우리가 알던 모든 CSS 속성명을 머릿속에서 카멜케이스로 번역해야만 합니다.\n조건부 렌더링을 하고 싶다고요?\n이제 ‘삼항 연산자 지옥’에 오신 것을 환영합니다.\n{ isLoggedIn ? ( \u0026lt;p\u0026gt;Welcome back!\u0026lt;/p\u0026gt; ) : isGuest ? ( \u0026lt;p\u0026gt;Welcome, guest!\u0026lt;/p\u0026gt; ) : ( \u0026lt;p\u0026gt;Please log in\u0026lt;/p\u0026gt; ); } 심지어 주석조차 평범하지 않은데요.\n\u0026lt;!-- 주석 --\u0026gt; 대신 {/* 주석 */}이라는 기괴한 문법을 써야만 합니다.\n개발자 친화적이라는 말이 무색하게, 주석 하나 다는 것조차 복잡하게 만들어 버렸죠.\n그래도 딱 하나 좋은 점 XSS 방지 그래도 딱 한 가지, JSX가 정말 잘하는 게 있는데요.\n바로 XSS(Cross-Site Scripting) 공격을 자동으로 방어해준다는 점입니다.\nJSX는 중괄호 안에 들어오는 모든 값을 문자열로 처리해서, 악성 스크립트가 실행되는 것을 원천적으로 차단하죠.\n물론 정말로 HTML을 렌더링하고 싶을 때는 dangerouslySetInnerHTML이라는 무시무시한 이름의 속성을 써야만 하는데요.\n마치 “그래, 정 쓰고 싶으면 쓰시든가.\n대신 ‘위험하다’는 단어를 직접 타이핑하게 만들어서 우리가 얼마나 이걸 못마땅해하는지 똑똑히 알려주겠어.“라고 말하는 것 같죠.\n컴포넌트 망치를 들면 모든 것이 못으로 보인다 리액트의 세계에서는 모든 것이 컴포넌트인데요.\n헤더도 컴포넌트, 버튼도 컴포넌트, 단어 사이의 공백조차도 컴포넌트로 만들어야 직성이 풀리는 것 같죠.\n‘재사용 가능한 UI 조각’이라는 합리적인 아이디어를 가져다가, 모든 div를 div를 반환하는 함수로 감싸야만 하는 종교로 만들어버렸습니다.\n평범한 div였으면 좋았을 것을 제가 본 최악의 리액트 안티패턴 중 하나는 바로 ‘단순 div를 위한 컴포넌트’인데요.\nconst Container = ({ children }) =\u0026gt; \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt;{children}\u0026lt;/div\u0026gt;; const Wrapper = ({ children }) =\u0026gt; \u0026lt;div className=\u0026#34;wrapper\u0026#34;\u0026gt;{children}\u0026lt;/div\u0026gt;; const Box = ({ children }) =\u0026gt; \u0026lt;div className=\u0026#34;box\u0026#34;\u0026gt;{children}\u0026lt;/div\u0026gt;; 축하합니다.\n당신은 방금 div에 클래스 하나 붙이면 될 일을, 더 많은 코드와 복잡성, 그리고 버그의 가능성을 추가해서 세 개의 컴포넌트로 만들어냈습니다.\nProps 끝없이 내려가는 문제 덩어리 Props는 리액트 컴포넌트들이 소통하는 방식인데요.\n마치 여러 사람이 한 줄로 서서 메시지를 전달하는 ‘전화기 게임’과 같습니다.\n모든 사람이 명시적으로 메시지를 전달해야 하고, 한 명이라도 잊어버리면 모든 것이 망가지죠.\n버튼 컴포넌트 하나를 만드는데, 그 설정 옵션(props)이 독일제 자동차보다 많아지는 경우도 허다합니다.\n그리고 새로운 prop을 하나 추가하려면, 그 컴포넌트를 사용하는 모든 곳을 다 찾아다니며 코드를 수정해야만 하죠.\n컴포넌트 구성과 ‘프로바이더 지옥’ 리액트는 ‘상속보다 구성(Composition over inheritance)‘을 장려하는데요.\n이 말은 그럴듯하게 들리지만, 실제로는 컴포넌트를 러시아 인형처럼 끝없이 중첩시키는 결과를 낳습니다.\n\u0026lt;ThemeProvider\u0026gt; \u0026lt;AuthProvider\u0026gt; \u0026lt;RouterProvider\u0026gt; \u0026lt;StoreProvider\u0026gt; \u0026lt;IntlProvider\u0026gt; \u0026lt;ErrorBoundary\u0026gt; \u0026lt;Suspense\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/ErrorBoundary\u0026gt; \u0026lt;/IntlProvider\u0026gt; \u0026lt;/StoreProvider\u0026gt; \u0026lt;/RouterProvider\u0026gt; \u0026lt;/AuthProvider\u0026gt; \u0026lt;/ThemeProvider\u0026gt; 이것이 바로 ‘프로바이더 지옥(Provider Hell)‘이라고 불리는 현상입니다.\n모든 기능이 자신만의 래퍼 컴포넌트를 필요로 할 때 발생하죠.\n우리의 실제 앱은 마치 디지털 고고학 유적지처럼, 일곱 겹의 추상화 계층 아래 깊숙이 묻혀버립니다.\n마치며 이번편에서 말하려는 건 명확한데요.\nJSX와 컴포넌트라는 개념 자체는 분명히 장점이 있습니다.\n컴포넌트 단위로 UI를 생각하면 복잡한 화면을 체계적으로 구성할 수 있고, JSX는 자바스크립트의 모든 능력을 템플릿 안에서 활용할 수 있게 해주죠.\n하지만 우리는 그 편리함을 위해 너무 많은 것을 포기해야만 했습니다.\n단순했던 HTML과 CSS, 그리고 명료했던 DOM 조작의 시대를 뒤로하고, 복잡한 빌드 과정과 기묘한 규칙들, 그리고 끝없는 추상화의 세계로 들어온 거죠.\n결국 스톡홀름 증후군이 발현될 때쯤이면, 우리도 JSX를 좋아하게 되고, 포럼에서 “그건 그냥 자바스크립트야!“라고 외치며 JSX를 옹호하게 될지도 모릅니다.\n그때가 바로 리액트가 완전히 승리한 순간이겠죠.\n다음 편에서는 이 모든 문제의 근원인 ‘상태 관리(State Management)‘에 대해 어떻게 독설을 퍼붓는지 살펴보도록 하겠습니다.\n","date":1755931255,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"418ab0e290c3d55380199913ff9d4da1","permalink":"http://localhost:1313/posts/2025-08-23-react-a-satirical-guide-part-2-jsx-components/","publishdate":"2025-08-23T15:40:55+09:00","relpermalink":"/posts/2025-08-23-react-a-satirical-guide-part-2-jsx-components/","section":"posts","summary":"리액트의 JSX는 왜 HTML이 아니면서 HTML인 척할까요? 모든 것을 컴포넌트로 만들라는 리액트의 철학은 과연 합리적일까요? 한 해외 개발 서적의 신랄한 시선으로 리액트의 핵심 개념을 파헤쳐 봅니다.","tags":["React","리액트","JSX","컴포넌트","리액트 입문","프론트엔드"],"title":"리액트를 배우셨군요 유감입니다 2편 (JSX와 컴포넌트, 아무도 원치 않았던 그 아이)","type":"posts"},{"authors":null,"categories":null,"content":"리액트를 배우셨군요 유감입니다 1편 (어느 냉소적인 개발자의 리액트 입문서) 이 글은 리액트를 어쩔 수 없이 배워야만 하는 개발자들을 위한, 일종의 ‘스톡홀름 증후군 환자 지원 그룹’ 같은 글로 생각하시면 됩니다.\n리액트를 배우는 과정을 ‘리액트 애도의 5단계’에 비유하는데, 이게 정말 기가 막힙니다.\n1단계는 ‘부정’이죠.\n“설마 이게 웹을 만드는 최선의 방법일 리가 없어.”\n2단계는 ‘분노’입니다.\n“아니 ‘Hello, World’ 하나 띄우는 데 파일이 왜 세 개나 필요한 건데?”\n3단계는 ‘타협’이고요.\n“음, 이 컴포넌트 하나에만 리액트를 써볼까…?”\n4단계는 ‘우울’입니다.\n“기능 개발보다 빌드 도구 설정하는 데 시간을 더 많이 쓰네… 내 node_modules 폴더 용량이 애플리케이션보다 크잖아.”\n그리고 마지막 5단계는 바로 ‘수용’이죠.\n“그래, 이게 내 인생이구나. 뭐, 취업은 잘 되겠지.”\n이 블로그 강좌의 신랄하면서도 유머러스한 시선을 따라가며, 우리가 왜 리액트를 증오하면서도 결국 배우게 되는지 그 웃픈 이유를 함께 파헤쳐 볼까 합니다.\n리액트는 대체 왜 태어났을까 2013년에 페이스북에는 큰 문제가 하나 있었는데요.\n서버가 불타거나 사용자가 떠나가는 그런 심각한 문제는 아니었습니다.\n바로 ‘알림 카운터 숫자가 가끔 틀리는’ 문제였죠.\n새 메시지가 3개라고 해서 클릭했더니 2개만 보이는 바로 그 상황, 그게 바로 리액트를 탄생시킨 세기의 위기였습니다.\n당시 웹 세상은 IE8이 아직도 쓰이고, 모바일 웹은 거의 작동하지 않던 시절이었는데요.\n그런 시대에 페이스북의 최우선 과제는 바로 그 작은 빨간 원 안의 숫자를 정확하게 맞추는 것이었죠.\n‘jQuery 스파게티 코드’라는 거대한 신화 리액트 전도사들이 퍼뜨린 가장 큰 거짓말 중 하나는 바로 ‘jQuery 스파게티 코드’ 신화인데요.\n그들이 주장하는 ‘유지보수 불가능한 스파게티 코드’가 실제로는 어땠는지 한번 보시죠.\n// 10년간 인터넷을 지탱해 온 바로 그 \u0026#39;스파게티 코드\u0026#39; $(\u0026#34;#submit-button\u0026#34;).on(\u0026#34;click\u0026#34;, function () { var username = $(\u0026#34;#username\u0026#34;).val(); $.post(\u0026#34;/api/login\u0026#34;, { username: username }, function (response) { if (response.success) { $(\u0026#34;#welcome-message\u0026#34;).text(\u0026#34;Welcome, \u0026#34; + response.name); $(\u0026#34;#login-form\u0026#34;).hide(); $(\u0026#34;#dashboard\u0026#34;).show(); } else { $(\u0026#34;#error-message\u0026#34;).text(response.error).show(); } }); }); 정말 끔찍하지 않나요?\n코드를 읽는 것만으로도 무슨 일을 하는지 바로 이해가 되다니 말이죠.\n빌드 과정도, 트랜스파일도, 가상돔 비교 알고리즘도 없이 그냥 ‘코드가 말하는 그대로’ 동작합니다.\n이제 이와 똑같은 기능을 하는 2013년 당시의 리액트 코드를 한번 보실까요.\nvar LoginComponent = React.createClass({ getInitialState: function () { /* ... */ }, handleUsernameChange: function (e) { /* ... */ }, handleSubmit: function (e) { /* ... */ }, render: function () { if (this.state.isLoggedIn) { return React.createElement(\u0026#34;div\u0026#34;, null /* ... */); } return React.createElement( \u0026#34;form\u0026#34;, { onSubmit: this.handleSubmit } /* ... */ ); }, }); 이 아름다운 모습을 보세요.\n똑같은 일을 하는 데 코드 양은 3배로 늘어났고, 이제 우리는 컴포넌트 생명주기, 상태 관리, 이벤트 바인딩, React.createElement 문법 같은 것들을 추가로 이해해야만 하죠.\n하지만 괜찮습니다.\n덕분에 페이스북의 알림 카운터는 정확해졌으니까요!\n조직의 문제를 기술의 문제로 사실 페이스북의 알림 문제는 기술의 문제가 아니었는데요.\n페이스북의 규모가 너무 커지면서 서로 다른 팀들이 각자의 코드를 건드리다 보니 충돌이 났던 ‘조직의 문제’였죠.\n하지만 그들은 “우리 좀 더 협력을 잘해볼까?“라고 말하는 대신, “웹 개발의 개념 자체를 처음부터 다시 만들자!“라고 외쳤습니다.\n열쇠를 못 찾겠다고 자기 집을 불태워버린 격이죠.\n결국 리액트는 페이스북이 가진 특정 문제를 해결하기 위한 특정 솔루션이었는데요.\n어쩌다 보니 그 솔루션이, 그 문제가 있든 없든 상관없이, 모두의 솔루션이 되어버린 겁니다.\n자바스크립트 피로감이라는 대재앙 2009년에는 메모장 하나만으로 웹사이트를 만들 수 있었는데요.\n2015년쯤 되자 ‘Hello, World’ 하나를 화면에 띄우기 위해 컴퓨터 과학 학위가 필요할 지경이 되었습니다.\njQuery 하나면 충분했던 황금기는 지나가고, Angular, Backbone, Ember 같은 프레임워크들이 등장하며 ‘프레임워크 대전쟁’이 시작되었죠.\n여기에 Node.js가 등장하면서 상황은 걷잡을 수 없이 복잡해졌습니다.\n프론트엔드 개발자들이 npm, 빌드 도구, 모듈 시스템, 트랜스파일러 같은 서버 생태계의 도구들을 손에 넣게 되면서 판도라의 상자가 열린 거죠.\nnpm은 처음엔 코드 공유를 쉽게 하자는 순수한 의도로 시작했는데요.\n하지만 지금은 npm install react 명령어 한 번에 수백 개의 패키지가 설치되는 시대가 되었습니다.\n수백 개의 잠재적 실패 지점, 수백 개의 잠재적 보안 취약점이 생겨난 셈이죠.\n2016년에 있었던 ’left-pad’ 사건을 기억하시나요?\n고작 11줄짜리 문자열 패딩 라이브러리가 npm에서 삭제되자 Babel, React를 포함한 인터넷의 절반이 멈춰 섰습니다.\n그 누구도 11줄짜리 패딩 함수를 직접 만들지 않게 된 거죠.\n빌드 도구의 역사도 눈물 없이는 볼 수 없는데요.\nGrunt는 설정이 너무 복잡했고, Gulp는 스트림 기반으로 조금 나아졌지만 여전히 복잡했습니다.\n그리고 Webpack이 등장해서 모든 것을 해결해 줄 것 같았지만, 결국 더 거대한 복잡성을 낳았죠.\n리액트가 JSX를 들고나오면서 HTML은 더 이상 순수한 HTML이 아니게 되었는데요.\nclass가 자바스크립트의 예약어라는 이유로 className이 되어버린 순간, 우리의 HTML은 ‘HTML인 척하는 자바스크립트’가 되어버린 겁니다.\n이 모든 과정이 바로 ‘자바스크립트 피로감’입니다.\n너무나 많은 도구들이 너무나 빠르게 변하고, 각자 자기가 필수라고 주장하는 바람에, 정작 무언가를 만들기보다는 새로운 도구를 배우는 데 모든 시간을 쏟게 되는 현상이죠.\n가상돔이라는 아름다운 거짓말 가상돔(Virtual DOM)은 리액트의 왕관에 박힌 보석이자, 리액트를 다른 모든 것보다 빠르게 만들어준다는 ‘킬러 기능’인데요.\n하지만 이건 리액트가 스스로 만들어낸 문제를 해결하기 위한 해결책에 가깝습니다.\n자기 다리를 부러뜨려 놓고 정말 멋진 목발을 발명한 것과 같죠.\n가상돔의 작동 방식을 거실 가구 재배치에 비유하면 이렇습니다.\n일반적인 방법은 그냥 옮겨야 할 가구만 옮기는 건데요.리액트의 방식은 이렇습니다.\n현재 거실의 완벽한 청사진을 그린다. 바꾸고 싶은 거실의 청사진을 또 그린다. 두 청사진을 아주 세세하게 비교한다. 최소한의 변경 사항 목록을 만든다. 그리고 오직 그때서야 가구를 옮긴다. 리액트 개발자들은 이게 더 효율적이라고 말하는데요.\n“가상돔이 실제돔보다 빠르다!“는 주장은 리액트의 가장 큰 슬로건이었습니다.\n하지만 브라우저 벤더들이 수십 년간 최적화해 온 실제돔 조작보다, 브라우저 위에서 돌아가는 자바스크립트 라이브러리가 더 빠를 수 있다는 생각 자체가 좀 이상하지 않나요?\n// \u0026#34;느리다\u0026#34;고 알려진 직접적인 DOM 조작 document.getElementById(\u0026#34;counter\u0026#34;).textContent = \u0026#34;1\u0026#34;; // 약 0.01ms 소요 // \u0026#34;빠르다\u0026#34;고 알려진 리액트 방식 // 1. 가상돔 트리 생성: ~0.1ms // 2. 가상돔 트리 비교(diffing): ~0.1ms // 3. 실제돔 업데이트: ~0.01ms // 총합: ~0.21ms 단순한 업데이트에서는 직접 DOM을 조작하는 게 압도적으로 빠릅니다.\n물론 리액트는 여러 업데이트를 묶어서 처리(batching)하기 때문에 복잡한 상황에서는 더 효율적일 수 있는데요.\n하지만 웹 애플리케이션의 99%는 그 정도의 복잡성을 가지고 있지 않죠.\n가상돔의 진짜 목적 가상돔의 진짜 목적은 ‘성능’이 아니라 ‘개발자 경험’에 있는데요.\n가상돔 덕분에 우리는 이렇게 ‘선언적으로’ UI를 작성할 수 있게 되었습니다.\nreturn \u0026lt;div\u0026gt;{user.name}\u0026lt;/div\u0026gt;; “여기에 사용자 이름이 보여야 해\u0026#34;라고 선언만 하면, 리액트가 그 상태를 만들기 위한 구체적인 방법(DOM 조작)을 알아서 처리해주는 거죠.\n이건 분명히 더 우아하고 생각하기 쉬운 방식입니다.\n하지만 그 대가로 우리는 더 느리고, 더 복잡하며, 우리와 브라우저 사이에 거대한 추상화 계층을 두게 된 거죠.\nSvelte 같은 프레임워크는 가상돔 없이도 선언적 UI를 구현할 수 있다는 것을 증명했는데요.\nSvelte는 컴파일 시점에 효율적인 DOM 조작 코드를 생성해내기 때문에, 런타임 오버헤드가 거의 없고 리액트보다 훨씬 빠릅니다.\n마치며 이 글은 리액트가 악마의 산물이라고 말하는 게 아닌데요.\n단지 ‘과잉 기술’이라는 점을 지적하고 있죠.\n액자 하나를 걸기 위해 슬레지해머를 사용하는 것과 같다는 겁니다.\n물론 액자는 벽에 걸리겠지만, 벽도 함께 박살 나겠죠.\n리액트는 페이스북 같은 거대하고 복잡한 애플리케이션에는 합리적인 선택일 수 있습니다.\n하지만 대부분의 웹사이트는 그 정도의 복잡성을 필요로 하지 않죠.\n우리는 리액트가 있기 전에도 훌륭한 웹사이트를 만들어왔고, 그 간단했던 방법들이 틀렸던 것이 아닙니다.\n하지만 어쩌겠어요.리액트는 이미 이겼고, 우리는 그걸 배워야만 합니다.\n이 책의 냉소적인 시선을 통해 우리가 잃어버린 단순함을 한번쯤  …","date":1755930850,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"989a03d5c410112a29936165a98d8cf4","permalink":"http://localhost:1313/posts/2025-08-23-react-a-satirical-guide-for-the-reluctant-developer/","publishdate":"2025-08-23T15:34:10+09:00","relpermalink":"/posts/2025-08-23-react-a-satirical-guide-for-the-reluctant-developer/","section":"posts","summary":"왜 우리는 리액트를 증오하면서도 결국 배우게 될까요? 한 해외 개발 서적의 신랄하고 유머러스한 시각을 통해 리액트의 탄생 비화, 자바스크립트 피로감, 그리고 가상돔의 진실을 파헤쳐 봅니다.","tags":["React","리액트","자바스크립트 피로감","가상돔","Virtual DOM","프론트엔드"],"title":"리액트를 배우셨군요 유감입니다 1편 (어느 냉소적인 개발자의 리액트 입문서)","type":"posts"},{"authors":null,"categories":null,"content":"React 상태 관리 완벽 가이드 useState부터 TanStack Query까지 React 애플리케이션을 개발하고 있다면, 거의 확실하게 어디에선가 ‘상태’를 관리하고 있을 겁니다.\n상태(state)는 의외로 정의하기는 어렵지만, 예시를 통해 이해하기는 훨씬 쉽습니다.\n가령 입력창은 현재 입력된 값을 상태로 가지고, 폼(form)은 그 안에 있는 모든 입력 값들을 상태로 가집니다.\n더 나아가 하나의 애플리케이션은 그 앱을 렌더링하고 운영하는 데 필요한 모든 데이터를 상태라고 할 수 있습니다.\n이것들은 상태에 대한 개념적인 예시인데요.React 컴포넌트 자체도 고유한 상태를 가지며, 종종 props를 통해 자식 컴포넌트에게 상태를 전달하기도 합니다.\n이번 포스트에서는 프론트엔드에서 관리되는 상태, 즉 ‘클라이언트 상태’를 관리하는 일반적인 방법들을 살펴보겠습니다.\n언제 어떤 패턴을 사용해야 하는지, 그리고 몇 가지 예시 코드와 함께 자세히 알아보겠습니다.\n서버 상태나 비동기 상태 관리는 후속 포스트에서 다룰 예정이었지만, 이 글의 마지막 부분에서 중요한 개념을 짚고 넘어가겠습니다.\n1부 기본기 다지기 가장 기본적인 상태 관리 도구는 역시 React에 내장된 훅(hook)입니다.\n가장 기본적인 원시 값 관리 useState 상태 관리를 시작하기 위한 가장 간단한 도구는 바로 useState입니다.\nuseState는 단일 값을 관리하는 React 훅으로, 현재 값과 그 값을 업데이트하는 함수를 배열 형태로 반환합니다.\nuseState는 상태가 최대 몇 개의 컴포넌트 내에서만 사용되는 단순한 경우에 빛을 발합니다.\nMantine의 메뉴 예시를 살펴보겠습니다.\nconst Demo = () =\u0026gt; { const [opened, setOpened] = useState(false); return ( \u0026lt;\u0026gt; \u0026lt;button onClick={() =\u0026gt; setOpened(true)}\u0026gt;메뉴 열기\u0026lt;/button\u0026gt; \u0026lt;Menu opened={opened} onChange={setOpened}\u0026gt; {/* 메뉴 콘텐츠 */} \u0026lt;/Menu\u0026gt; \u0026lt;/\u0026gt; ); }; 버튼을 클릭하면 opened가 true로 설정되고 메뉴가 열립니다.\n이보다 더 쉬울 수는 없지만, 상황이 조금 더 복잡해지기 시작하면 어떨지 살펴보겠습니다.\n복잡한 상태 업데이트와 useReducer 물론 불리언(boolean) 값만으로 애플리케이션을 만들 수는 없습니다.\n분명 더 복잡한 상호작용과 이를 위한 복잡한 데이터 구조가 필요해질 겁니다.\n복잡성을 한 단계 높여서, 우리가 부동산 앱의 주택 검색 필터를 만들고 있다고 상상해 보겠습니다.\n이 전체 폼은 궁극적으로 백엔드에 전송될 하나의 쿼리(query) 객체를 생성하기 위해 설계되었습니다.\n단순화된 쿼리 객체의 모습은 다음과 같을 겁니다.\ntype Query = { zipCode?: string; minPrice?: number; maxPrice?: number; homeTypes?: string[]; requiredFeatures: { hasFireplace?: boolean; hasWasherDryler?: boolean; // ... 등등 }; // ... 등등 }; 이제 이 필드들을 각각 관리하는 여러 컴포넌트를 만들어야 합니다.\n가장 순진한 접근 방식은 useState를 사용하는 것입니다.\nconst HomeBuyingFilters = () =\u0026gt; { const [query, setQuery] = useState(getDefaultFilterQuery()); // TODO: 쿼리에 대한 데이터 가져오기 return ( \u0026lt;div\u0026gt; \u0026lt;ZipCodeFilter query={query} setQuery={setQuery} /\u0026gt; \u0026lt;PriceFilter query={query} setQuery={setQuery} /\u0026gt; \u0026lt;HomeTypesFilter query={query} setQuery={setQuery} /\u0026gt; \u0026lt;RequiredFeaturesFilter query={query} setQuery={setQuery} /\u0026gt; \u0026lt;ResetAllFiltersButton setQuery={setQuery} /\u0026gt; \u0026lt;/div\u0026gt; ); }; 각 필터 컴포넌트는 query 객체에서 자신에게 필요한 부분을 가져와 setQuery로 원하는 변경을 가할 수 있습니다.\n이 방식이 끔찍한 것은 아니지만, 각 컴포넌트가 필요하지도 않은 전체 query 객체를 전달받는 것은 조금 어색하게 느껴집니다.\n더 나쁜 것은 디버깅이 고통스러워질 수 있다는 점입니다.\n만약 ‘우편번호가 가끔 무작위로 초기화돼요’ 같은 버그를 추적해야 한다면, 어디서부터 확인해야 할지 막막할 겁니다.\nsetQuery를 호출하는 모든 곳이 잠재적인 용의자이기 때문입니다.\n그래서 우리는 각 상태 변경에 대한 전용 함수를 만드는 멋진 아이디어를 떠올립니다.\nconst HomeBuyingFilters = () =\u0026gt; { const [query, setQuery] = useState(getDefaultFilterQuery()); const setZipCode = zipCode =\u0026gt; { setQuery(currentQuery =\u0026gt; ({ ...currentQuery, zipCode })); }; const setMinPrice = minPrice =\u0026gt; { setQuery(currentQuery =\u0026gt; ({ ...currentQuery, minPrice })); }; return ( \u0026lt;div\u0026gt; \u0026lt;ZipCodeFilter zipCode={query.zipCode} setZipCode={setZipCode} /\u0026gt; \u0026lt;PriceFilter minPrice={query.minPrice} maxPrice={query.maxPrice} setMinPrice={setMinPrice} setMaxPrice={setMaxPrice} /\u0026gt; {/* ... 등등 */} \u0026lt;/div\u0026gt; ); }; 이 방식은 zipCode에 대한 모든 변경이 HomeBuyingFilters 컴포넌트 내에 정의된 함수에 포함되어 있어 추적이 훨씬 쉬워진다는 장점이 있습니다.\nZipCodeFilter 컴포넌트도 이제 전체 query 객체 대신 zipCode와 setZipCode만 알면 됩니다.\n하지만 해결하면 좋을 두 가지 단점이 여전히 남아있습니다.\n하나는 상태 업데이트 로직을 특정 컴포넌트 안에 모두 몰아넣는 것이 어색하다는 점이고, 다른 하나는 새로운 업데이트 함수를 만들 때마다 필요한 컴포넌트에 prop을 계속 연결해줘야 한다는 점입니다.\n바로 이 지점에서 useReducer가 유용하게 사용될 수 있습니다.\nuseReducer 예제 useReducer는 크게 세 가지 요소로 생각할 수 있습니다.\n첫째는 ‘상태(state)‘입니다.\n우리 예시에서는 Query 타입이 해당됩니다.\n둘째는 ‘액션(action)‘입니다.\n우리 예시에서는 setZipCode나 setMinPrice 같은 ‘상태에 영향을 줄 수 있는 행위’를 의미합니다.\n셋째는 ‘리듀서(reducer)‘입니다.\n이는 상태와 액션을 입력받아 업데이트된 새로운 상태를 반환하는 순수 함수입니다.\n위 예시를 useReducer를 사용해 다시 작성해 보겠습니다.\n// queryState.ts // 액션 타입을 enum으로 관리하면 편리합니다. export enum QueryActionType { SET_ZIP_CODE = \u0026#34;SET_ZIP_CODE\u0026#34;, SET_MIN_PRICE = \u0026#34;SET_MIN_PRICE\u0026#34;, // 등등 } // 액션은 상태 변경에 대한 \u0026#39;설명\u0026#39;입니다. 타입 외에 데이터도 필요합니다. export type QueryAction = | { type: QueryActionType.SET_ZIP_CODE; payload: string; } | { type: QueryActionType.SET_MIN_PRICE; payload: number | undefined; }; // 리듀서는 액션을 적용한 후의 최신 상태를 반환합니다. // 반드시 새로운 객체를 생성해야 하며, 기존 상태(query)를 직접 수정해서는 안 됩니다. export function queryStateReducer(query: Query, action: QueryAction): Query { switch (action.type) { case QueryActionType.SET_ZIP_CODE: return { ...query, zipCode: action.payload }; case QueryActionType.SET_MIN_PRICE: return { ...query, minPrice: action.payload }; // 등등 default: return query; } } 이제 이 로직을 useReducer로 필터 컴포넌트에 연결할 수 있습니다.\nconst HomeBuyingFilters = () =\u0026gt; { const [query, dispatch] = useReducer( queryStateReducer, getDefaultFilterQuery() ); return ( \u0026lt;div\u0026gt; \u0026lt;ZipCodeFilter zipCode={query.zipCode} dispatch={dispatch} /\u0026gt; \u0026lt;PriceFilter minPrice={query.minPrice} maxPrice={query.maxPrice} dispatch={dispatch} /\u0026gt; {/* 등등 */} \u0026lt;/div\u0026gt; ); }; 마지막으로, 각 자식 컴포넌트에서 dispatch 함수를 호출합니다.\nconst ZipCodeFilter = ({ zipCode, dispatch }) =\u0026gt; { const setZipCode = newZipCode =\u0026gt; { // dispatch는 우리가 정의한 \u0026#39;액션\u0026#39; 객체를 인자로 받습니다. // 이 액션은 리듀서에 정의된 로직에 따라 상태를 자동으로 업데이트합니다. dispatch({ type: QueryActionType.SET_ZIP_CODE, payload: newZipCode, }); }; // 나머지 로직 }; 이 구조의 멋진 점은 ZipCodeFilter가 ‘나는 SET_ZIP_CODE 액션을 발생시킨다’라고 명시적으로 선언한다는 것입니다.\n만약 CLEAR_ZIP_CODE라는 새로운 액션을 추가하고 싶다면, …","date":1752893514,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"4bd69cc00b84a20794f40f51abd26b38","permalink":"http://localhost:1313/posts/2025-07-18-react-state-management-complete-guide/","publishdate":"2025-07-19T11:51:54+09:00","relpermalink":"/posts/2025-07-18-react-state-management-complete-guide/","section":"posts","summary":"React의 상태 관리 기법을 useState, useReducer, Context API부터 Zustand, TanStack Query와 같은 최신 라이브러리까지 종합적으로 다룹니다. 클라이언트 상태와 서버 상태를 구분하여 올바른 도구를 선택하는 방법을 배워보세요.","tags":["React","상태 관리","useState","useReducer","Context API","Zustand"],"title":"React 상태 관리 완벽 가이드 useState부터 TanStack Query까지","type":"posts"},{"authors":null,"categories":null,"content":"왜 TanStack Router는 리액트 개발의 판도를 바꾸는가? 웹 애플리케이션을 구축할 때 ‘라우터’를 선택하는 것은 가장 중요한 아키텍처 결정 중 하나입니다.\n라우터는 단순히 node_modules에 있는 또 하나의 의존성이 아닙니다.\n애플리케이션 전체를 하나로 묶어주는 뼈대와도 같습니다.\n사용자가 페이지를 오갈 때 훌륭한 경험을 제공해야 함은 물론, 개발자가 수많은 라우트를 추가하면서도 제정신을 유지할 수 있도록 멋진 개발 경험(DX)을 제공해야 이상적이죠.\n기존 라우터들은 저마다 장점이 있었지만, ‘모든 것을 가질 수 있다’는 느낌을 주지는 못했습니다.\n타입 안정성이 아쉽거나, URL 상태 관리가 번거롭거나, 불필요한 리렌더링으로 성능 저하를 감수해야 하는 경우가 많았죠.\n하지만 최근 v1을 출시한 TanStack Router는 이 모든 고민을 해결할 완벽한 대안으로 떠올랐습니다.\n이 글에서는 TanStack Router가 다른 라우터들과 차별화되는 핵심적인 기능들을 깊이 있게 파헤쳐 보고, 왜 이것이 당신의 다음 프로젝트의 ‘게임 체인저’가 될 수밖에 없는지 보여드리겠습니다.\n1. 지긋지긋한 any와의 작별: 압도적인 타입 안정성 기존 라우터들의 타입 지원은 마치 나중에 덧붙인 것처럼 어설픈 경우가 많았습니다.\nuseParams 훅은 Record\u0026lt;string, string | undefined\u0026gt;를 반환하며 “나머지는 알아서 하세요\u0026#34;라고 말하는 듯합니다. \u0026lt;Link\u0026gt; 컴포넌트는 to 프롭으로 어떤 string이든 받습니다. /issues/${issueId} 같은 URL이 유효한지, issueId가 제대로 전달되었는지는 오롯이 개발자의 책임이었습니다. 이는 TypeScript가 대중화되기 전, 순수 JavaScript 시절의 유산처럼 느껴집니다.\n하지만 TanStack Router는 태생부터 TypeScript와 함께하기 위해 설계되었습니다.\n모든 기능이 완벽하게 추론되는 타입 안정성을 염두에 두고 만들어졌죠.\n- 똑똑해진 useParams\nTanStack Router의 useParams는 현재 어떤 라우트에 있는지 명확하게 알려줘야 합니다.\n// 1. 가장 이상적인 사용법: \u0026#39;from\u0026#39;으로 출처 명시 const { issueId } = useParams({ from: \u0026#34;/issues/$issueId\u0026#34; }); // ^? 타입: const issueId: string from에 전달하는 경로는 모든 라우트의 유니온 타입으로 자동 완성되기 때문에 잘못 쓸 염려가 없습니다.\nissueId는 string 타입으로 완벽하게 추론되며, 만약 다른 라우트에서 이 컴포넌트를 잘못 사용하면 런타임 에러가 발생하여 실수를 즉시 바로잡을 수 있습니다.\n재사용 가능한 컴포넌트를 만들고 싶다면 strict: false 옵션을 주면 됩니다.\n// 2. 재사용 컴포넌트를 위한 방법: \u0026#39;strict: false\u0026#39; const params = useParams({ strict: false }); // ^? 타입: const params: { // issueId: string | undefined, // dashboardId: number | undefined // } 이 방식은 런타임 에러를 발생시키지 않으면서, 라우터가 아는 모든 경로 파라미터의 유니온 타입을 반환합니다.\nissueId나 dashboardId가 존재할 수도, 아닐 수도 있다는 사실을 타입으로 명확히 알려줍니다.\n이보다 더 안전할 수 있을까요?\n- 실수를 허용하지 않는 \u0026lt;Link\u0026gt; 컴포넌트\n\u0026lt;Link\u0026gt; 컴포넌트 역시 마찬가지입니다.\n라우터가 모든 경로를 알고 있기 때문에, to와 params를 잘못 전달하면 즉시 타입 에러를 띄워줍니다.\n\u0026lt;Link to=\u0026#34;/issues/$issueId\u0026#34; params={{ issueId: \u0026#34;TSR-25\u0026#34; }}\u0026gt; Go to details \u0026lt;/Link\u0026gt; 위 코드에서 issueId를 빼먹거나, 다른 이름의 id를 전달하거나, string이 아닌 값을 주거나, 존재하지 않는 URL로 이동하려고 하면 TypeScript가 즉시 당신을 막아줄 것입니다.\n2. URL 검색 파라미터, 이제는 검증의 시대 URL의 검색 파라미터(?page=1\u0026amp;filter=open)는 사용자가 직접 수정할 수 있기 때문에 신뢰할 수 없는 값으로 취급해야 합니다.\n그래서 항상 유효성 검사가 필요했죠.\n그런데, “라우터가 검색 파라미터를 검증해주면 안 되나?“라는 합리적인 의문이 듭니다.\nTanStack Router는 바로 그 일을 합니다.\n라우트 정의에서 직접 검색 파라미터의 유효성을 검사할 수 있습니다.\n// routes/issues.tsx import { createFileRoute } from \u0026#34;@tanstack/react-router\u0026#34;; import { z } from \u0026#34;zod\u0026#34;; // Zod나 ArkType, Valibot 등 사용 가능 // 1. 검색 파라미터 스키마 정의 const issuesSearchSchema = z.object({ page: z.number().min(1).default(1), filter: z.string().optional().default(\u0026#34;\u0026#34;), }); // 2. 라우트 정의 시 스키마를 이용해 유효성 검사 export const Route = createFileRoute(\u0026#34;/issues\u0026#34;)({ validateSearch: issuesSearchSchema, }); 이제 useSearch({ from: \u0026#39;/issues\u0026#39; })를 호출하면, 반환되는 값은 완벽하게 검증되고 타입이 지정된 객체입니다.\npage는 기본값이 1인 숫자, filter는 기본값이 빈 문자열인 선택적 문자열이 되죠.\n라우터가 파싱과 직렬화까지 알아서 처리해주니 개발자는 비즈니스 로직에만 집중할 수 있습니다.\n3. 불필요한 리렌더링을 막는 정밀한 상태 구독 (Selectors) 기존 라우터에서는 URL이 조금만 바뀌어도 해당 URL을 구독하는 모든 컴포넌트가 리렌더링되는 문제가 있었습니다.\n예를 들어, 테이블 필터 값이 URL에 저장된 페이지에서 특정 행을 클릭해 다이얼로그(서브 라우트)를 열면, URL이 바뀌면서 거대한 테이블 컴포넌트까지 불필요하게 리렌더링되는 것이죠.\n이는 마치 Redux나 Zustand 같은 상태 관리 라이브러리가 필요한 이유와 같습니다.\n거대한 상태의 일부만 구독하여, 내가 관심 있는 값이 바뀔 때만 리렌더링하는 것이죠.\nTanStack Router는 바로 이 ‘셀렉터(selector)’ 기능을 내장하고 있습니다.\nconst page = useSearch({ from: \u0026#34;/issues\u0026#34;, select: search =\u0026gt; search.page, // 전체 search 객체가 아닌 \u0026#39;page\u0026#39;만 구독 }); select 옵션을 사용하면 search 객체 전체가 아닌 search.page 값의 변경에만 반응하여 컴포넌트가 리렌더링됩니다.\n이는 useParams, useLoaderData 등 다양한 훅에서 지원되며, 복잡한 페이지에서 극적인 성능 최적화를 이끌어냅니다.\n4. 라우팅 패러다임의 진화: 파일 기반 라우팅 1세대 (선언적 라우팅): \u0026lt;Route\u0026gt; 컴포넌트를 JSX 안에 흩뿌려 놓는 방식은 유지보수의 악몽이었습니다. 특정 URL이 어떤 컴포넌트 트리 깊숙한 곳에서 정의되었는지 찾기 어려웠죠. 2세대 (코드 기반 라우팅): 모든 라우트 정의를 하나의 설정 객체로 모으는 방식은 타입 안정성을 확보하는 데 큰 도움이 되었습니다. 3세대 (파일 기반 라우팅): TanStack Router는 여기서 한 걸음 더 나아갑니다. 라우트 설정을 파일 시스템 구조로 옮겨버리는 것이죠. src/routes/issues/$issueId.tsx 라는 파일 구조는 그 자체로 issues/:issueId 경로를 의미합니다.\n이는 버그 리포트에서 본 URL을 코드와 즉시 매핑할 수 있는 가장 빠른 방법이며, 라우트 기반 코드 분할(Code Splitting)을 자동으로 구현하는 최고의 방법이기도 합니다.\n물론, 원한다면 전통적인 코드 기반 라우팅도 완벽하게 지원합니다.\n5. 데이터 로딩과의 완벽한 통합 (feat. Suspense) TanStack Router는 React Suspense 및 ErrorBoundary와 완벽하게 통합됩니다.\n모든 라우트는 기본적으로 \u0026lt;Suspense\u0026gt;와 \u0026lt;ErrorBoundary\u0026gt;로 감싸져 있죠.\n여기에 TanStack Query를 결합하면 놀라운 시너지가 발생합니다.\n// routes/issues/$issueId.tsx export const Route = createFileRoute(\u0026#34;/issues/$issueId\u0026#34;)({ // 컴포넌트가 렌더링되기 전에 데이터를 미리 가져옴 loader: ({ context: { queryClient }, params: { issueId } }) =\u0026gt; { queryClient.prefetchQuery(issueQueryOptions(issueId)); }, component: IssueComponent, }); function IssueComponent() { const { issueId } = Route.useParams(); // useSuspenseQuery를 사용하면 데이터가 항상 존재함을 보장받음 const { data } = useSuspenseQuery(issueQueryOptions(issueId)); // ^? 타입: const data: Issue (undefined가 아님!) // 이제 로딩, 에러 상태 처리 없이 \u0026#39;happy path\u0026#39; 렌더링에만 집중! return \u0026lt;div\u0026gt;{data.title}\u0026lt;/div\u0026gt;; } loader에서 데이터를 미리 가져오고, 컴포넌트에서는 useSuspenseQuery를 사용해 데이터가 보장된 상태로 렌더링에만 집중할 수 있습니다.\n로딩과 에러 상태는 라우터가 상위 경계(Boundary)에서 알아서 처리해줍니다.\n한번 빠지면 헤어나올 수 없는 매력 TanStack Router를 한번 경험하고 나면, 다른 라우팅 솔루션으로 돌아가기 어려워집니다.\n그만큼 압도적인 타입 안정성과 개발자 경험에 중독되기 때문입니다.\n이 글에서는 라우트 컨텍스트, 중첩 라우트, SSR 프레임워크인 TanStack Start 등 더 많은 기 …","date":1752670761,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"3db501434f954721ee8ff35432dd6bba","permalink":"http://localhost:1313/posts/2025-07-15-why-tanstack-router-is-a-game-changer-for-react-apps/","publishdate":"2025-07-16T21:59:21+09:00","relpermalink":"/posts/2025-07-15-why-tanstack-router-is-a-game-changer-for-react-apps/","section":"posts","summary":"기존 리액트 라우터의 한계를 넘어, 완전한 타입 안정성과 뛰어난 개발 경험(DX)을 제공하는 TanStack Router의 핵심 기능들을 깊이 있게 분석합니다. 이 글을 통해 왜 TanStack Router가 차세대 웹 애플리케이션의 필수 선택지가 되어가고 있는지 확인하세요.","tags":["TanStack Router","리액트","타입스크립트","라우터","타입 안정성","React","TypeScript","Router","Type-Safety","TanStack Query","상태 관리","파일 기반 라우팅","DX","개발자 경험"],"title":"왜 TanStack Router는 리액트 개발의 판도를 바꾸는가?","type":"posts"},{"authors":null,"categories":null,"content":"React useState 완전 정복 - 비동기 동작부터 최적화까지 (초보자가 겪는 모든 함정) 우리는 React의 내부 메커니즘, 모범 사례, 디자인 패턴, 그리고 고급 개념들을 탐구합니다.\n이 글들은 기본을 넘어 React가 내부적으로 어떻게 작동하는지 진정으로 이해하고자 하는 React 개발자들을 위해 작성되었습니다.\n상태(State)란 무엇인가? ‘상태(State)‘는 React의 가장 핵심적인 개념 중 하나입니다.\n이는 컴포넌트 내에서 시간이 지남에 따라 변할 수 있는 데이터를 나타냅니다.\n부모 컴포넌트로부터 전달받아 자식 컴포넌트 입장에서는 변경할 수 없는 ‘props’와는 달리, 상태는 컴포넌트 내부에 존재하며 수정될 수 있습니다.\nuseState 훅은 현대 React의 함수형 컴포넌트에서 이러한 지역 상태를 관리하는 주요 해결책이며, React 애플리케이션의 모든 상호작용의 기초를 형성합니다.\nuseState 훅의 기본 useState 훅은 함수형 컴포넌트에 지역 상태를 추가할 수 있게 해주는 함수입니다.\n간단한 예시를 통해 어떻게 작동하는지 살펴보겠습니다.\nimport React, { useState } from \u0026#34;react\u0026#34;; function Counter() { // \u0026#34;count\u0026#34;라는 상태 변수를 선언하고 0으로 초기화합니다. const [count, setCount] = useState(0); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 이 예시에서:\nuseState(0)는 상태 값을 0으로 초기화합니다. 이 함수는 두 개의 요소를 가진 배열을 반환하며, 우리는 이를 ‘배열 구조 분해 할당’으로 받습니다. count: 현재 상태 값입니다. setCount: 이 상태를 업데이트하는 함수입니다. setCount가 호출될 때마다, React는 count의 새로운 값을 가지고 컴포넌트를 ‘리렌더링(re-render)‘합니다.\nuseState의 비동기적 본질 useState의 중요하면서도 종종 오해받는 측면은 바로 ‘비동기적’ 행동입니다.\n여러분이 상태 업데이트 함수(setter 함수)를 호출할 때, React는 즉시 상태 값을 변경하지 않습니다.\n대신, 이 업데이트를 ‘스케줄링’합니다.\n이는 마치 “나중에 이 값으로 상태를 업데이트해줘\u0026#34;라고 React에게 요청하는 것과 같습니다.\n이러한 동작은 예상치 못한 버그를 유발할 수 있습니다.\nfunction AsynchronousExample() { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { // 이 라인은 \u0026#39;count\u0026#39;를 즉시 수정하지 않습니다. 업데이트를 예약할 뿐입니다. setCount(count + 1); // 따라서 이 시점의 \u0026#39;count\u0026#39;는 여전히 이전 값(렌더링 시점의 값)입니다. console.log(count); // 새로운 값이 아닌, 이전 \u0026#39;count\u0026#39; 값을 보여줍니다. }; return \u0026lt;button onClick={handleClick}\u0026gt;Increment ({count})\u0026lt;/button\u0026gt;; } 이 문제를 해결하기 위해, useState는 ‘함수형 업데이트(functional update)‘라는 대안을 제공합니다.\n상태 업데이트 함수에 값을 직접 전달하는 대신, 함수를 전달하는 것입니다.\nfunction FunctionalUpdateExample() { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { // 이전 상태(previous state)를 인자로 받는 함수를 사용합니다. setCount(prevCount =\u0026gt; prevCount + 1); // 만약 여러 업데이트를 수행해야 한다면 setCount(prevCount =\u0026gt; prevCount + 1); setCount(prevCount =\u0026gt; prevCount + 1); // 이 코드는 \u0026#39;count\u0026#39;를 3만큼 증가시킵니다. }; return \u0026lt;button onClick={handleClick}\u0026gt;Multiple increment ({count})\u0026lt;/button\u0026gt;; } 이 함수형 업데이트는 React가 아직 컴포넌트를 리렌더링하지 않았더라도, 항상 가장 최신의 상태 값을 가지고 작업할 것을 보장해 줍니다.\n여러 업데이트를 하나의 이벤트 핸들러에서 처리할 때, 항상 함수형 업데이트를 사용하는 것이 안전합니다.\n게으른 초기화 (Lazy Initialization) useState를 사용할 때, 매개변수로 전달된 초기값이 어떻게 처리되는지 이해하는 것이 중요합니다.\n값을 직접 전달하는 것과 초기화 함수를 전달하는 것 사이에는 결정적인 차이가 있습니다.\n문제점: 매 렌더링마다 재계산 useState에 값이나 표현식을 직접 전달하면, 이 표현식은 컴포넌트가 렌더링될 때마다 매번 평가됩니다.\nfunction ExpensiveInitExample() { // 문제점: complexCalculation()이 모든 렌더링마다 실행됩니다. const [value, setValue] = useState(complexCalculation()); console.log(\u0026#34;Component rendered\u0026#34;); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Value: {value}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 이 예제에서, 우리는 오직 초기값에만 관심이 있음에도 불구하고, complexCalculation() 함수는 컴포넌트가 리렌더링될 때마다 불필요하게 호출됩니다.\n만약 이 함수가 리소스를 많이 소모한다면 성능에 심각한 영향을 미칠 수 있습니다.\n해결책: 초기화 함수 이 문제를 해결하기 위해, React는 useState에 초기화 함수를 전달하는 것을 허용합니다.\n이 함수는 오직 첫 번째 렌더링 동안 단 한 번만 호출됩니다.\nfunction LazyInitExample() { // 올바른 방법: 이 함수는 오직 첫 렌더링 시에만 한 번 호출됩니다. const [value, setValue] = useState(() =\u0026gt; { console.log(\u0026#34;비싼 계산 수행 중...\u0026#34;); return complexCalculation(); }); console.log(\u0026#34;Component rendered\u0026#34;); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Value: {value}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setValue(value + 1)}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } 이 버전에서는 complexCalculation이 오직 컴포넌트의 초기 마운트 시에만 한 번 실행됩니다.\nReact는 단순히 함수가 반환한 값을 초기화에 사용하고, 이후 렌더링에서는 이 함수를 무시합니다.\n‘게으른 초기화(Lazy initialization)‘는 다음과 같은 상황에서 특히 유용합니다.\n비싼 계산 (대용량 데이터 처리) localStorage나 Web Storage API에서 데이터 읽기 복잡한 props 분석 또는 변환 복잡한 객체 관리: 불변성의 원칙 상태가 객체나 배열일 때, ‘불변성(immutability)’ 원칙을 존중하는 것이 매우 중요합니다.\nReact는 객체의 참조를 비교하여 상태가 변경되었는지 판단합니다.\n만약 상태 객체를 직접 수정하면, React는 변경을 감지하지 못하고 컴포넌트를 리렌더링하지 않을 것입니다.\nfunction ObjectStateExample() { const [user, setUser] = useState({ name: \u0026#34;Alice\u0026#34;, age: 25, preferences: { theme: \u0026#34;dark\u0026#34; }, }); const updateTheme = newTheme =\u0026gt; { // 잘못된 방법 - 상태를 직접 수정 // user.preferences.theme = newTheme; // setUser(user); // 객체 참조가 동일하므로 리렌더링을 유발하지 않음 // 올바른 방법 - 새로운 객체 생성 setUser({ ...user, // 기존 user 객체의 속성을 복사 preferences: { ...user.preferences, // 중첩된 객체도 복사 theme: newTheme, // 원하는 속성만 변경 }, }); }; // ... } useState vs useReducer 상태 업데이트 로직이 복잡해진다면, useState 대신 useReducer를 고려하는 것이 좋습니다.\nuseReducer는 상태 업데이트 로직을 컴포넌트 외부로 분리하고, 여러 다른 종류의 액션을 중앙에서 관리할 수 있게 해줍니다.\n일반적으로 다음과 같은 경우에 useReducer가 더 선호됩니다.\n상태들이 서로 의존적일 때 업데이트 로직이 복잡할 때 (예: 여러 필드를 가진 폼) 상태를 수정하는 액션의 종류가 많을 때 성능 최적화: 리렌더링 제어하기 상태 업데이트는 리렌더링을 유발하며, 이는 성능에 영향을 줄 수 있습니다.\nReact는 선별적으로 사용할 수 있는 몇 가지 최적화 기법을 제공합니다.\nReact.memo: props가 변경되지 않았다면 컴포넌트의 리렌더링을 방지하는 고차 컴포넌트입니다. useCallback: 렌더링 사이에 함수를 기억(메모이제이션)합니다. React.memo로 감싸진 자식 컴포넌트에 함수를 prop으로 전달할 때 특히 유용합니다. useMemo: 렌더링 사이에 계산 결과를 기억합니다. 매 렌더링마다 비싼 값을 재계산하는 것을 피하기 위해 사용됩니다. React 19와 컴파일러에 대한 참고 사항 React 19에서 도입될 ‘React 컴파일러’를 사용하면, 이러한 수동 최적화 중 일부는 이전보다 덜 필요하게 됩니다.\n컴파일러는 React.memo, useMemo, useCallback이 필요했을 많은 경우를 자동으로 감지하고 최적화할 수 있습니다.\n하지만 이러한 API들은 여전히 컴파일러가 자동으로 최적화할 수 없는 복잡한 경우에 유용하게 남을 것입니다.\n일반적인 규칙은, 이러한 최적화 없이 시작하고, …","date":1752374888,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"0f013e9e37c7d58f2dbd1ceed722b0bb","permalink":"http://localhost:1313/posts/2025-07-13-react-usestate-deep-dive-from-basics-to-optimization/","publishdate":"2025-07-13T11:48:08+09:00","relpermalink":"/posts/2025-07-13-react-usestate-deep-dive-from-basics-to-optimization/","section":"posts","summary":"React의 가장 기본 훅, useState의 모든 것을 알아봅니다. 비동기 업데이트의 함정, 게으른 초기화, 불변성, 클로저 문제부터 useReducer와의 비교, 그리고 React.memo, useCallback, useMemo를 사용한 성능 최적화까지 깊이 있게 탐구합니다.","tags":["React","useState","React 훅","상태 관리","비동기","불변성","성능 최적화"],"title":"React useState 완전 정복 - 비동기 동작부터 최적화까지 (초보자가 겪는 모든 함정)","type":"posts"},{"authors":null,"categories":null,"content":"React useReducer 완전 정복 - useState의 한계를 넘어 구조적인 상태 관리하기 우리는 React의 내부 메커니즘, 모범 사례, 디자인 패턴, 그리고 고급 개념들을 탐구합니다.\n이 글들은 기본을 넘어 React가 내부적으로 어떻게 작동하는지 진정으로 이해하고자 하는 React 개발자들을 위해 작성되었습니다.\n상태 관리가 복잡해질 때 상태 관리는 React 애플리케이션 개발의 근본적인 측면 중 하나입니다.\n지난 시리즈 글에서 우리는 함수형 컴포넌트에서 지역 상태를 관리하는 가장 기본적인 방법인 useState 훅을 탐구했습니다.\n하지만 컴포넌트가 복잡해지고 상태 로직이 정교해지면서, useState는 금세 그 한계를 드러내기 시작합니다.\n바로 이 지점에서 useReducer 훅이 등장합니다.\n이 훅은 복잡한 상태를 관리하기 위한 더 구조적인 접근 방식을 제공하며, 특히 상태 업데이트가 이전 상태에 의존하거나 상태의 다른 부분들이 서로 상호 의존적일 때 강력한 힘을 발휘합니다.\nRedux 패턴에서 영감을 받은 useReducer는 비즈니스 로직이 더 엄격한 구성을 요구하는 시나리오에서 useState의 강력한 대안이 됩니다.\nuseState의 한계: 쇼핑 카트 예제 useReducer의 가치를 이해하기 위해, 먼저 useState의 한계를 구체적인 예제, 즉 이커머스 쇼핑 카트를 관리하는 경우를 통해 살펴보겠습니다.\n만약 useState만으로 쇼핑 카트를 구현한다면, 코드는 대략 이런 모습일 것입니다.\nfunction ShoppingCartWithUseState() { // 여러 상태들이 흩어져 있습니다. const [items, setItems] = useState([]); const [total, setTotal] = useState(0); const [itemCount, setItemCount] = useState(0); const [discount, setDiscount] = useState(0); const [isCheckingOut, setIsCheckingOut] = useState(false); // ... // 아이템을 추가하는 함수 const addItem = product =\u0026gt; { // ... 아이템 추가 로직 ... const newItems = updateItems(items, product); setItems(newItems); // 관련된 다른 상태들도 \u0026#39;수동으로\u0026#39; 모두 업데이트해야 합니다. const newTotal = calculateTotal(newItems, discount); const newItemCount = calculateItemCount(newItems); setTotal(newTotal); setItemCount(newItemCount); }; // 아이템을 제거하는 함수 const removeItem = productId =\u0026gt; { // ... 아이템 제거 로직 ... const newItems = filterItems(items, productId); setItems(newItems); // 여기서도 관련된 모든 상태를 다시 계산하고 업데이트해야 합니다. const newTotal = calculateTotal(newItems, discount); const newItemCount = calculateItemCount(newItems); setTotal(newTotal); setItemCount(newItemCount); }; // ... 기타 다른 함수들 (할인 적용, 결제 등) } 이 코드에는 몇 가지 심각한 문제가 있습니다.\n‘분산된 비즈니스 로직’: 장바구니 관리 로직이 addItem, removeItem 등 여러 함수에 흩어져 있고, total과 itemCount를 다시 계산하는 코드가 중복됩니다. ‘누락의 위험’: 각 함수는 여러 상태(items, total, itemCount)를 수동으로 업데이트해야 하므로, 실수로 하나라도 빠뜨리면 버그가 발생합니다. ‘산발적인 업데이트 로직’: 할인 적용 같은 계산 규칙이 여러 곳에 흩어져 있어 일관성을 유지하기 어렵습니다. ‘중앙 관리의 부재’: 가능한 모든 상태 전환을 한눈에 파악하기가 어렵습니다. ‘테스트의 어려움’: 비즈니스 로직이 이벤트 핸들링과 섞여 있어 테스트가 복잡해집니다. useReducer 이해하기: 지휘 센터 만들기 useReducer 훅은 상태 로직을 ‘리듀서(reducer)‘라고 불리는 순수 함수에 중앙 집중화하여 이러한 문제들을 해결합니다.\n마치 복잡한 교통 시스템을 통제하는 ‘중앙 관제소’를 만드는 것과 같습니다.\nuseReducer란 무엇인가? useReducer의 기본 구문은 다음과 같습니다.\nconst [state, dispatch] = useReducer(reducer, initialState); state: 모든 데이터를 단일 객체에 그룹화한 현재 상태입니다. dispatch: 리듀서에 ‘액션(action)‘을 보내는 함수입니다. 마치 관제소에 “사고 발생!” 또는 “도로 개통!” 같은 ‘사건’을 보고하는 무전기와 같습니다. reducer: 현재 상태와 액션을 받아 ‘새로운 상태’를 반환하는 순수 함수입니다. 관제소의 핵심 두뇌 역할을 합니다. initialState: 초기 상태입니다. 리듀서 패턴 useReducer의 핵심은 리듀서 함수입니다.\n이 함수는 (state, action) =\u0026gt; newState라는 형태를 가지며, 반드시 ‘순수 함수’여야 합니다.\n즉, 원본 상태를 직접 수정해서는 안 되며(불변성 원칙), 부수 효과가 없어야 합니다.\n‘액션’은 일반적으로 수행할 작업의 종류를 나타내는 type 속성과, 필요한 데이터를 담는 payload 속성을 가진 객체입니다.\nuseReducer로 리팩터링하기: 쇼핑 카트 예제 이제 useReducer로 쇼핑 카트를 어떻게 리팩터링하는지 보겠습니다.\n1단계: 타입과 초기 상태, 그리고 리듀서 정의 먼저 필요한 모든 타입과 초기 상태, 그리고 모든 로직을 담을 리듀서 함수를 정의합니다.\n이들은 컴포넌트 외부에 위치할 수 있어, 로직과 뷰의 분리가 명확해집니다.\n// 타입 정의 type CartState = { /* ... */ }; type CartAction = | { type: \u0026#34;ADD_ITEM\u0026#34;; payload: Product } | { type: \u0026#34;REMOVE_ITEM\u0026#34;; payload: { id: string } } // ... 기타 액션 타입 // 초기 상태 const initialState: CartState = { /* ... */ }; // 중앙 관제소: 리듀서 함수 function cartReducer(state: CartState, action: CartAction): CartState { switch (action.type) { case \u0026#34;ADD_ITEM\u0026#34;: { // ... 아이템 추가 로직 ... const updatedItems = /* ... */; // 관련된 모든 파생 상태를 여기서 한 번에 계산합니다. const newTotal = calculateTotal(updatedItems, state.discount); const newItemCount = calculateItemCount(updatedItems); // \u0026#39;새로운 상태\u0026#39; 객체를 반환합니다. return { ...state, items: updatedItems, total: newTotal, itemCount: newItemCount, }; } case \u0026#34;REMOVE_ITEM\u0026#34;: { // ... 아이템 제거 로직 ... const updatedItems = /* ... */; const newTotal = calculateTotal(updatedItems, state.discount); const newItemCount = calculateItemCount(updatedItems); return { ...state, items: updatedItems, total: newTotal, itemCount: newItemCount, }; } // ... 다른 모든 케이스 ... default: return state; } } 2단계: 컴포넌트에서 useReducer 사용하기 이제 컴포넌트는 훨씬 더 단순해집니다.\n복잡한 상태 업데이트 로직 대신, 단지 어떤 일이 일어났는지를 설명하는 ‘액션’을 dispatch하기만 하면 됩니다.\n// useReducer를 사용하는 컴포넌트 function ShoppingCartWithReducer() { const [state, dispatch] = useReducer(cartReducer, initialState); const { items, total, itemCount } = state; // 제품 추가 const addToCart = (product: Product) =\u0026gt; { // \u0026#34;ADD_ITEM 액션이 발생했어!\u0026#34;라고 보고합니다. dispatch({ type: \u0026#34;ADD_ITEM\u0026#34;, payload: product }); }; // 제품 제거 const removeFromCart = (id: string) =\u0026gt; { dispatch({ type: \u0026#34;REMOVE_ITEM\u0026#34;, payload: { id } }); }; // 결제 처리 const checkout = async () =\u0026gt; { dispatch({ type: \u0026#34;CHECKOUT_START\u0026#34; }); try { await processPayment(items, total); dispatch({ type: \u0026#34;CHECKOUT_SUCCESS\u0026#34; }); } catch (error) { dispatch({ type: \u0026#34;CHECKOUT_FAILURE\u0026#34;, payload: { error: \u0026#34;Payment failed\u0026#34; } }); } }; // ... 컴포넌트 렌더링 ... } 이 접근 방식의 장점은 명확합니다.\n‘비즈니스 로직 중앙화’: 모든 장바구니 관련 작업이 단일 리듀서 함수에 그룹화됩니다. ‘명시적인 액션’: 각 작업이 ADD_ITEM처럼 명시적으로 이름 붙은 액션으로 표현되어 코드가 스스로를 문서화합니다. ‘계산 일관성’: 파생된 계산(총액, 아이템 수)이 항상 같은 방식으로 수행되어 데이터 일관성이 보장됩니다. ‘향상된  …","date":1752371288,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"f77d23eb43a3d9878d2d600ccbe21319","permalink":"http://localhost:1313/posts/2025-07-13-mastering-react-usereducer-for-structured-state-management/","publishdate":"2025-07-13T10:48:08+09:00","relpermalink":"/posts/2025-07-13-mastering-react-usereducer-for-structured-state-management/","section":"posts","summary":"useState만으로 상태 관리가 힘들어질 때, useReducer가 어떻게 구원투수가 되는지 알아봅니다. 쇼핑 카트 예제를 통해 상태 로직을 중앙에서 관리하고, 예측 가능하며 테스트하기 쉬운 코드를 작성하는 방법을 깊이 있게 탐구합니다.","tags":["React","useReducer","useState","상태 관리","리액트 훅","상태 기계","리팩터링"],"title":"React useReducer 완전 정복 - useState의 한계를 넘어 구조적인 상태 관리하기","type":"posts"},{"authors":null,"categories":null,"content":"React useEffect 완전 정복 - 동기화 관점으로 레벨업하기 우리는 React의 내부 메커니즘, 모범 사례, 디자인 패턴, 그리고 고급 개념들을 탐구합니다.\n이 글들은 기본을 넘어 React가 내부적으로 어떻게 작동하는지 진정으로 이해하고자 하는 React 개발자들을 위해 작성되었습니다.\nuseEffect의 본질을 꿰뚫기 useEffect 훅은 현대 React의 근본적인 기둥입니다.\n단순한 함수 그 이상으로, 컴포넌트가 변화에 반응하고 비동기 작업을 수행하면서도 UI의 일관성을 유지할 수 있게 해줍니다.\n하지만 그 명백한 단순함 뒤에는 미묘한 에러를 유발하고 애플리케이션의 성능과 유지보수성에 영향을 미칠 수 있는 복잡성이 숨어 있습니다.\n이번 ‘Level Up React’ 시리즈 글에서는 useEffect의 내부 메커니즘, 종종 오해받는 미묘함, 그리고 숙련된 개발자조차도 기다리는 흔한 함정들을 깊이 있게 탐구해 보겠습니다.\n올바른 사용법이 어떻게 여러분의 코드를 더 예측 가능하고 성능 좋게 변화시킬 수 있는지 확인해 보겠습니다.\nuseEffect의 기본 useEffect는 왜 존재할까? React는 함수형 컴포넌트에서 ‘부수 효과(side effects)‘를 효율적으로 관리하기 위해 useEffect를 만들었습니다.\n이것이 도입되기 전에는, 이러한 작업들은 componentDidMount, componentDidUpdate, componentWillUnmount와 같은 클래스 컴포넌트의 생명주기 메서드에 예약되어 있었습니다.\n‘부수 효과’란 React 컴포넌트 외부의 무언가를 수정하는 모든 작업을 의미합니다.\n예를 들면 다음과 같습니다.\nAPI 요청 보내기 DOM을 직접 조작하기 (예: 문서 제목 변경) 이벤트 리스너 추가 또는 제거하기 타이머 설정하기 (setTimeout, setInterval) 가장 중요한 개념은 useEffect를 ‘무언가를 하기 위한’ 도구가 아니라, ‘React의 상태를 외부 시스템과 동기화(synchronize)하기 위한’ 도구로 바라보는 것입니다.\n// 부수 효과의 예: 페이지 제목 수정하기 useEffect(() =\u0026gt; { // \u0026#39;username\u0026#39;이라는 React 상태를 브라우저의 \u0026#39;document.title\u0026#39;이라는 외부 시스템과 동기화합니다. document.title = `Profile of ${username}`; }, [username]); 이 예제에서 문서 제목을 수정하는 것은 React 컴포넌트 외부의 환경에 영향을 미치기 때문에 부수 효과입니다.\nuseEffect 훅은 우리가 이 작업을 언제 발생해야 하는지 명시적으로 선언할 수 있게 해줍니다.\nuseEffect의 해부학 useEffect 훅은 두 개의 인자를 받습니다.\nuseEffect( () =\u0026gt; { // 이펙트 본문 (실행할 코드) return () =\u0026gt; { // 클린업(정리) 함수 (선택 사항) }; }, [ /* 의존성 배열 */ ] ); ‘첫 번째 인자 (이펙트 함수)’: 실행할 코드를 담고 있는 함수입니다. 이 함수는 ‘클린업 함수’를 반환할 수 있는데, 이 클린업 함수는 다음 이펙트가 실행되기 전이나 컴포넌트가 언마운트될 때 호출됩니다. ‘두 번째 인자 (의존성 배열)’: 이펙트가 언제 실행되어야 하는지를 결정합니다. React는 렌더링 사이에 이 배열의 값들을 비교하여 이펙트를 다시 실행할지 여부를 결정합니다. useEffect의 실행 주기 useEffect는 언제 실행될까요?\n일반적인 믿음과는 달리, useEffect는 컴포넌트의 렌더링 도중에 실행되지 않고, React가 DOM을 업데이트한 후에 실행됩니다.\n정확한 작업 순서는 다음과 같습니다.\nReact가 컴포넌트 본문을 실행하고 표시할 JSX를 계산합니다. React가 이 JSX를 반영하도록 DOM을 업데이트합니다. React가 useEffect로 정의된 이펙트들을 실행합니다. 이 순서는 이펙트 동작을 이해하는 데 매우 중요합니다.\n의존성 배열로 실행 제어하기 의존성 배열은 이펙트가 언제 실행되어야 하는지를 제어하는 핵심 메커니즘입니다.\nReact는 Object.is() 비교 알고리즘을 사용하여 의존성이 변경되었는지 판단합니다.\n‘의존성 배열 없음’: 이펙트가 ‘모든 렌더링 후에’ 실행됩니다. 이는 불필요한 실행과 성능 문제를 유발할 수 있으므로 거의 사용되지 않는 구성입니다. ‘빈 의존성 배열 []’: 이펙트가 ‘첫 렌더링 후에만’ 한 번 실행됩니다. WebSocket 연결 설정과 같은 일회성 초기화에 유용합니다. ‘의존성이 있는 배열 [count]’: 이펙트가 첫 렌더링 후, 그리고 의존성(count)이 변경될 때마다 실행됩니다. 클린업 메커니즘 클린업 함수는 useEffect의 종종 간과되는 중요한 측면입니다.\n이펙트가 다시 실행되거나 컴포넌트가 언마운트되기 전에 리소스를 정리하거나 구독을 취소할 수 있게 해줍니다.\nuseEffect(() =\u0026gt; { // 인터벌 생성 const intervalId = setInterval(() =\u0026gt; { console.log(\u0026#34;Tick\u0026#34;); }, 1000); // 클린업 함수 return () =\u0026gt; { console.log(\u0026#34;인터벌 정리 중\u0026#34;); clearInterval(intervalId); }; }, []); 이 예제에서 클린업 함수는 컴포넌트가 언마운트될 때 인터벌이 제대로 제거되도록 보장하여, 메모리 누수를 방지합니다.\n흔한 함정과 피하는 방법 무한 루프 가장 빈번한 문제 중 하나는 의도치 않은 무한 루프 생성입니다.\n이 문제는 이펙트의 의존성인 상태를 업데이트하는 데이터 페칭 시나리오에서 자주 발생합니다.\n// 실제 사례에서 무한 루프 생성 function NotificationCenter() { const [notifications, setNotifications] = useState([]); useEffect(() =\u0026gt; { fetchNotifications().then(newNotifications =\u0026gt; { // 이 업데이트는 새로운 렌더링을 유발합니다. setNotifications([...notifications, ...newNotifications]); }); }, [notifications]); // notifications가 의존성입니다. } 이 예제에서는 fetchNotifications()가 데이터를 반환할 때마다 notifications 상태를 업데이트합니다.\nnotifications가 우리 이펙트의 의존성이므로, 이는 이펙트의 새로운 실행을 유발하여 API 요청의 무한 루프를 만듭니다.\n// 해결책: 함수형 업데이터 사용 function NotificationCenter() { const [notifications, setNotifications] = useState([]); useEffect(() =\u0026gt; { fetchNotifications().then(newNotifications =\u0026gt; { // 이 형태의 setState는 현재 상태에 의존할 필요가 없습니다. setNotifications(prevNotifications =\u0026gt; [ ...prevNotifications, ...newNotifications, ]); }); }, []); // 마운트 시 한 번만 실행 } 누락되거나 불필요한 의존성 또 다른 흔한 함정은 필요한 의존성을 생략하거나 불필요한 의존성을 포함하는 것입니다.\n// 누락된 의존성 function UserProfile({ userId }) { const [user, setUser] = useState(null); useEffect(() =\u0026gt; { fetchUser(userId).then(data =\u0026gt; setUser(data)); }, []); // userId가 의존성에서 빠져 있습니다. } 이 예제에서, userId가 변경되더라도 이펙트는 다시 실행되지 않습니다.\neslint-plugin-react-hooks 플러그인이 포함된 ESLint 도구는 이러한 문제를 자동으로 감지하는 데 매우 유용합니다.\n객체와 함수를 의존성으로 사용하기 렌더링 중에 생성된 객체와 함수는 각 렌더링마다 재생성되므로 새로운 값으로 간주되어 특별한 문제를 야기합니다.\n// 매 렌더링마다 재생성되는 객체 function SearchComponent({ term }) { // 이 객체는 매 렌더링마다 재생성됩니다. const options = { caseSensitive: false }; useEffect(() =\u0026gt; { performSearch(term, options); }, [term, options]); // options는 매 렌더링마다 변경됩니다. } term이 변경되지 않았더라도 options가 재생성되어 이펙트가 매번 실행됩니다.\n해결책은 useMemo나 useCallback을 사용하거나, 객체나 함수를 이펙트 내부로 옮기는 것입니다.\nuseEffect를 사용하지 말아야 할 때 React 공식 문서는 ‘아마 이펙트가 필요 없을지도 모릅니다(You Might Not Need an Effect)‘라는 매우 유용한 가이드를 제공합니다.\n‘파생된 값 계산하기’: 기존 상태에서 파생된 값을 계산하기 위해 useEffect를 사용하는 것은 흔한 실수입니다. 렌더링 중에 직접 계산하거나, 계산 비용이 비싸다면 useMemo를 사용하세요. ‘사용자 이벤트에 반응하기’: 사용자 이벤트에 반응하기 위해 useEffect를 사용하는 것은 종종 복잡하고 유지보수하기 어려운 아키텍처로 이어집니다. 이벤트 핸들러에서 직접 로직을 호출하는 것이 더 간단하고 직접적입니다. ‘상태 변수 초기화하기’: useEffect를 사용하여 상태 변수를 초기화하는 것은 종종 불필요합니다. useState의 ‘게으른 초기화’를 사용하는 것이 더 간단하고 효율적입니다. useEffect의 올바른 사용 사례 useEffect는 컴포넌트를 외부 시스템과 ‘동기화’할 때 이상적입니다.\n외부 시스템과 동기화 (DOM, 서드파티 API 등) 이벤트 구독 (키보드 단축키, BroadcastChannel 등) 데이터 페칭 결론 useEffect 훅은 올바르게 사용하기 위해 깊은 이해가 필요한 강력하지만 미묘한 도구입니다.\n우리가 보았듯이, 이 훅은 React 컴포넌트를 외부 시스템과 동기화할 수 있 …","date":1752367688,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"85144886e89befecb4f1a6d94bb52a80","permalink":"http://localhost:1313/posts/2025-07-13-mastering-react-useeffect-the-synchronization-mindset/","publishdate":"2025-07-13T09:48:08+09:00","relpermalink":"/posts/2025-07-13-mastering-react-useeffect-the-synchronization-mindset/","section":"posts","summary":"useEffect는 단순한 생명주기 훅이 아닙니다. React의 상태를 외부 세계와 동기화하는 관점에서 useEffect의 실행 주기, 의존성 배열의 함정, 클린업 함수의 정확한 타이밍, 그리고 흔한 오용 사례까지 깊이 있게 탐구합니다.","tags":["React","useEffect","React 훅","부수 효과","동기화","상태 관리","성능 최적화"],"title":"React useEffect 완전 정복 - 동기화 관점으로 레벨업하기","type":"posts"},{"authors":null,"categories":null,"content":"React Context API 완전 정복 - Prop Drilling을 넘어 최적화와 상태 관리 철학까지 우리는 React의 내부 메커니즘, 모범 사례, 디자인 패턴, 그리고 고급 개념들을 탐구합니다.\n이 글들은 기본을 넘어 React가 내부적으로 어떻게 작동하는지 진정으로 이해하고자 하는 React 개발자들을 위해 작성되었습니다.\n‘Prop Drilling’이라는 고통 상태 관리는 React 애플리케이션 개발의 근본적인 과제입니다.\n우리는 이전 시리즈 글에서 useState와 useReducer를 탐구했지만, 이 훅들은 주로 컴포넌트의 ‘지역 상태’를 관리하도록 설계되었습니다.\n만약 컴포넌트 트리에서 멀리 떨어져 있는 여러 컴포넌트가 동일한 상태에 접근해야 한다면 어떻게 될까요?\n이때 우리는 ‘prop drilling’이라는 고통스러운 문제에 직면하게 됩니다.\n마치 할아버지가 손자에게 용돈을 주기 위해, 중간에 있는 아들에게 “이거 네 아들한테 좀 전해줘\u0026#34;라고 부탁해야 하는 상황과 같습니다.\n중간에 있는 컴포넌트들은 정작 자신은 그 데이터(prop)를 사용하지도 않으면서, 오직 자식에게 전달하기 위해 불필요하게 props를 계속해서 넘겨줘야 합니다.\n바로 이 지점에서 React의 ‘Context API’가 등장합니다.\n이것은 전역 상태 관리를 위한 React의 내장 솔루션입니다.\n이번 글에서는 Context의 내부 작동 방식, 최적화 기법, 그리고 애플리케이션에서 효과적으로 사용하는 방법을 깊이 있게 탐구해 보겠습니다.\nContext API의 내부 동작 원리 React의 Context API는 종종 ‘prop drilling’을 피하기 위한 간단한 해결책으로 제시됩니다.\n하지만 그 이면에서는 실제로 어떤 일이 벌어지고 있을까요?\n컨텍스트 생성하기 createContext를 호출하면, React는 두 개의 중요한 컴포넌트를 포함하는 객체를 생성합니다.\nconst MyContext = React.createContext(defaultValue); // MyContext 객체는 사실 { Provider, Consumer } 형태입니다. defaultValue는 트리에서 해당 컨텍스트를 소비하는 컴포넌트 위에 상응하는 부모 Provider가 없을 때만 사용됩니다.\n실제 애플리케이션에서는 드문 경우이며, 보통은 버그의 원인이 되곤 합니다.\n전파 메커니즘: ‘방송국과 라디오’ Context 시스템은 ‘구독(subscription)’ 메커니즘에 의존하여, 컨텍스트 값이 변경되었을 때 소비하는 컴포넌트들에게 알림을 보냅니다.\n마치 라디오 방송국과 같습니다.\nProvider가 렌더링되면, 자신의 하위 트리(subtree)에 대해 ‘현재 컨텍스트’라는 방송 채널을 설정하고 값을 송출합니다. useContext나 Consumer를 사용하는 각 컴포넌트는 이 방송 채널에 ‘구독’ 신청을 합니다. Provider의 value가 변경되면, 방송국은 “주파수 청취자 여러분, 새로운 소식입니다!“라고 알리고, 구독한 모든 컴포넌트는 알림을 받아 리렌더링됩니다. 여기서 매혹적인 점은 이 전파가 중간에 있는 컴포넌트들을 완전히 건너뛴다는 것입니다.\n부모 컴포넌트가 컨텍스트를 제공하고, 아주 깊숙이 중첩된 컴포넌트가 그것을 소비할 수 있으며, 그 사이의 컴포넌트들은 이 통신에 대해 전혀 영향을 받지도, 알지도 못합니다.\nfunction App() { const [theme, setTheme] = useState(\u0026#34;light\u0026#34;); return ( // \u0026#39;ThemeContext\u0026#39; 방송국이 \u0026#39;light\u0026#39;라는 값을 송출합니다. \u0026lt;ThemeContext.Provider value={theme}\u0026gt; \u0026lt;Layout\u0026gt; {\u0026#34; \u0026#34;} {/* Layout은 이 컨텍스트를 전혀 모릅니다. */} \u0026lt;ThemeToggle onChange={setTheme} /\u0026gt; \u0026lt;/Layout\u0026gt; \u0026lt;/ThemeContext.Provider\u0026gt; ); } // 이 컴포넌트는 아주 깊이 중첩될 수 있습니다. function ThemeToggle({ onChange }) { // \u0026#39;ThemeContext\u0026#39; 채널을 구독하여 현재 값을 받습니다. const theme = useContext(ThemeContext); return ( \u0026lt;button onClick={() =\u0026gt; onChange(theme === \u0026#34;light\u0026#34; ? \u0026#34;dark\u0026#34; : \u0026#34;light\u0026#34;)}\u0026gt; Current: {theme} \u0026lt;/button\u0026gt; ); } Provider의 역할과 성능 함정 Provider 컴포넌트는 value prop이 변경될 때 소비자 컴포넌트의 업데이트를 유발합니다.\nProvider는 Object.is() 비교 알고리즘을 사용하여 값이 변경되었는지 판단합니다.\n이는 이해해야 할 중요한 포인트인데, 왜냐하면 매 렌더링마다 새로 생성된 객체를 전달하는 것이 왜 성능 문제를 일으키는지 설명해 주기 때문입니다.\n// 문제점: 매 렌더링마다 새로운 객체 function App() { const [user, setUser] = useState({ name: \u0026#34;Alice\u0026#34; }); return ( // App이 리렌더링될 때마다, 이 { user, setUser } 객체는 새로 생성됩니다. // 이전 객체와 내용은 같아도 \u0026#39;참조(reference)\u0026#39;가 다르므로, React는 값이 변경되었다고 판단합니다. \u0026lt;UserContext.Provider value={{ user, setUser }}\u0026gt; \u0026lt;UserProfile /\u0026gt; \u0026lt;/UserContext.Provider\u0026gt; ); } 이 예제에서, user 객체의 내용이 변경되지 않더라도, 매 렌더링마다 새로운 { user, setUser } 객체가 생성되어 소비자 컴포넌트의 불필요한 리렌더링을 유발합니다.\nContext를 위한 최적화 기법 1. useMemo로 값 메모이제이션하기 가장 효과적인 기법 중 하나는 컨텍스트 값을 메모이제이션하여 매 렌더링마다 새로운 객체가 생성되는 것을 방지하는 것입니다.\nfunction App() { const [user, setUser] = useState({ name: \u0026#34;Alice\u0026#34; }); // 컨텍스트 값의 메모이제이션 const userContextValue = useMemo(() =\u0026gt; { return { user, setUser }; }, [user]); // user가 변경될 때만 새로운 객체가 생성됩니다. return ( \u0026lt;UserContext.Provider value={userContextValue}\u0026gt; \u0026lt;UserProfile /\u0026gt; \u0026lt;/UserContext.Provider\u0026gt; ); } 2. 컨텍스트 분리하기: ‘상태’와 ‘액션’의 분리 또 다른 강력한 접근 방식은 자주 변경되는 데이터와 거의 변경되지 않는 데이터를 분리하는 것입니다.\n가장 일반적인 패턴은 ‘상태(state)‘와 그 상태를 변경하는 ‘액션(actions)’ 또는 ‘디스패치(dispatch)’ 함수를 별개의 컨텍스트로 나누는 것입니다.\n// 두 개의 개별 컨텍스트로 분리 const UserStateContext = createContext(null); const UserActionsContext = createContext(null); function UserProvider({ children }) { const [user, setUser] = useState({ name: \u0026#34;Alice\u0026#34; }); // 액션 함수들은 한 번만 생성되고 거의 변하지 않습니다. (useCallback 사용) const actions = useMemo( () =\u0026gt; ({ updateName: name =\u0026gt; setUser(prev =\u0026gt; ({ ...prev, name })), logout: () =\u0026gt; setUser(null), }), [] ); return ( \u0026lt;UserActionsContext.Provider value={actions}\u0026gt; \u0026lt;UserStateContext.Provider value={user}\u0026gt; {children} \u0026lt;/UserStateContext.Provider\u0026gt; \u0026lt;/UserActionsContext.Provider\u0026gt; ); } 이 접근 방식은 컴포넌트가 필요한 컨텍스트만 소비하게 하여 리렌더링 횟수를 줄여줍니다.\n예를 들어, 이름만 업데이트하는 버튼 컴포넌트는 UserActionsContext만 소비하면 됩니다.\nuser 상태가 다른 이유로 변경되더라도, 이 버튼 컴포넌트는 리렌더링되지 않습니다.\nContext API vs. 외부 라이브러리 (Zustand, Redux) Context API가 강력하지만, 다른 인기 있는 전역 상태 관리 솔루션도 있습니다.\nContext vs. Zustand Zustand는 미니멀한 상태 관리 라이브러리로, Context API의 핵심적인 단점을 해결합니다.\n‘선택적 구독(Selectors)’: Zustand의 가장 큰 강점입니다. 컴포넌트는 전체 스토어가 아닌, 자신이 필요한 ‘특정 상태 조각’만 구독할 수 있습니다. 따라서 관련 없는 상태가 변경되어도 리렌더링이 발생하지 않습니다. ‘단순함’: Redux보다 훨씬 적은 보일러플레이트와 간단한 API를 제공합니다. ‘Provider 불필요’: 앱을 Provider로 감쌀 필요가 없습니다. Context vs. Redux Redux는 React 생태계에서 가장 확고한 상태 관리 솔루션입니다.\n‘예측 가능성’: 단방향 데이터 흐름과 불변 상태를 통해 상태 변화를 예측하고 추적하기 쉽습니다. ‘풍부한 생태계’: 수많은 미들웨어, 디버깅 도구(Redux DevTools의 타임 트래블 디버깅 등), 확장 기능이 존재합니다. ‘장황함’: 간단한 기능에도 많은 보일러플레이트 코드가 필요하며, 학습 곡선이 가파릅니다. 언제 무엇을 사용해야 할까? ‘Context API를 사용할 때’: 자주 변경되지 않는 데이터를 공유할 때 (예: 테마, 사용자 인증 정보) 상태 구조가 비교적 단순할 때 외부 라이브러리 의존성을 최소화하고 싶을 때 소규모에서 중간 규모의 애플리케이션 ‘Zustand나 Redux 같은 외부 라이브러리를 사용할 때’: 애플리케이션 상태가 복잡하고 상호작용이 많을 때 타임 트래블 디버깅, 미들웨어 등 고급 기능이 필요할 때 성능이 매우 중요하여, 불필요한 리렌더링을 최소화해야 할 때 여 …","date":1752364088,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"ad9d74495f9796f0aba896bbcecb8a62","permalink":"http://localhost:1313/posts/2025-07-13-mastering-react-context-api-deep-dive/","publishdate":"2025-07-13T08:48:08+09:00","relpermalink":"/posts/2025-07-13-mastering-react-context-api-deep-dive/","section":"posts","summary":"React의 내장 상태 관리 도구, Context API의 모든 것을 알아봅니다. prop drilling 문제 해결부터 내부 동작 원리, useMemo를 활용한 최적화, 그리고 Redux, Zustand와의 비교를 통해 언제 Context를 사용해야 하는지 깊이 있게 탐구합니다.","tags":["React Context","prop drilling","상태 관리","useState","useReducer","Zustand","Redux"],"title":"React Context API 완전 정복 - Prop Drilling을 넘어 최적화와 상태 관리 철학까지","type":"posts"},{"authors":null,"categories":null,"content":"React의 진짜 반응성 - 35줄 코드로 Context API의 함정 넘어서기 우리는 React의 내부 메커니즘, 모범 사례, 디자인 패턴, 그리고 고급 개념들을 탐구합니다.\n이 글들은 기본을 넘어 React가 내부적으로 어떻게 작동하는지 진정으로 이해하고자 하는 React 개발자들을 위해 작성되었습니다.\n서론: 반응성은 정말 어려운 걸까? ‘반응성(Reactivity)‘이라는 개념은 React 생태계에서 여전히 오해받고 있는 것 같습니다.\n저는 MUI X Data Grid에서 이 문제를 어떻게 해결했는지에 대한 글을 제공하고 싶었습니다.\n제 생각에, 세밀한 ‘선택자 기반 반응성’은 React에서 35줄 미만의 코드로도 가능하며, 이 글의 끝에서는 바로 복사-붙여넣기 할 수 있는 예제를 제공할 것입니다.\n문제를 가장 미니멀한 해결책으로 축소할 수 있는 것은 중요하다고 생각합니다.\n왜냐하면 그것이 문제의 본질을 더 명확하게 보여주기 때문입니다.\n단순함은 또한 우리 코드가 가져야 할 가장 높은 목표 중 하나입니다.\n단순한 코드에서 쉬운 유지보수성과 쉬운 성능 최적화가 나오기 때문이죠.\n문제에 대한 가장 미니멀한 해결책을 이해하는 것은, 여러분이 이해하지 못하는 미리 만들어진 해결책을 물려받는 대신, 그것을 기반으로 구축해 나갈 수 있게 해줍니다.\n당면한 문제: Context API의 ‘과잉 방송’ Data Grid에서 겪었던 문제를 재현하기 위해, 간단한 실행 가능한 예제가 있습니다.\n‘Cell’ 컴포넌트들이 내부에 있는 ‘Grid’입니다.\n그리드의 루트에 있는 상태에 현재 포커스된 셀을 저장하고, 각 셀은 포커스를 받으면 그 상태를 업데이트할 수 있습니다.\nconst Context = createContext(); function Grid() { const [focus, setFocus] = useState(0); // 매번 새로운 value 객체가 생성되는 것을 막기 위해 useMemo 사용 const contextValue = useMemo(() =\u0026gt; ({ focus, setFocus }), [focus]); return ( \u0026lt;Context.Provider value={contextValue}\u0026gt; {Array.from({ length: 50 }).map((_, i) =\u0026gt; ( \u0026lt;Cell key={i} index={i} /\u0026gt; ))} \u0026lt;/Context.Provider\u0026gt; ); } function Cell({ index }) { const context = useContext(Context); const isFocused = context.focus === index; console.log(`Cell ${index} is rendering`); return ( \u0026lt;button onClick={() =\u0026gt; context.setFocus(index)} className={isFocused ? \u0026#34;focus\u0026#34; : \u0026#34;\u0026#34;} \u0026gt; {index} \u0026lt;/button\u0026gt; ); } 이 그리드에서 셀 하나를 클릭하면 어떻게 될까요?\n아마 여러분의 콘솔은 “Cell 0 is rendering”, “Cell 1 is rendering”, … “Cell 49 is rendering\u0026#34;으로 도배될 것입니다.\n셀 하나를 클릭했을 뿐인데, 50개의 모든 셀이 리렌더링되는 재앙이 발생합니다.\n이것이 바로 Context API의 근본적인 한계입니다.\n마치 마을 방송 시스템과 같습니다.\n‘1번 집에 우편물이 도착했다’는 소식을 알리기 위해, 마을 전체에 스피커로 방송하는 셈이죠.\nContext.Provider의 value가 변경되면, useContext를 통해 이 컨텍스트를 ‘구독’하는 모든 컴포넌트는 그 값의 일부만 사용하더라도 무조건 리렌더링됩니다.\n셀의 개수가 많아지고 각 셀의 렌더링 비용이 비싸진다면, 이는 만족스럽지 못한 상황입니다.\n해결책: 35줄 미만의 ‘선택적 구독’ 시스템 제가 35줄 미만의 코드로 해결책을 약속했죠.\n여기 있습니다.\n‘스토어(Store)‘는 본질적으로 변경될 때 콜백을 트리거하는 ref 객체일 뿐입니다.\n그리고 그 콜백들은 각 컴포넌트에서 setState 훅 함수를 호출함으로써 목표로 한 리렌더링을 트리거하기만 하면 됩니다.\nimport { useState, useEffect } from \u0026#34;react\u0026#34;; type Listener\u0026lt;S\u0026gt; = (state: S) =\u0026gt; void; class Store\u0026lt;State\u0026gt; { private state: State; private listeners: Set\u0026lt;Listener\u0026lt;State\u0026gt;\u0026gt;; constructor(initialState: State) { this.state = initialState; this.listeners = new Set(); } public subscribe = (listener: Listener\u0026lt;State\u0026gt;): (() =\u0026gt; void) =\u0026gt; { this.listeners.add(listener); return () =\u0026gt; { this.listeners.delete(listener); }; }; public update = (newState: State) =\u0026gt; { if (newState !== this.state) { this.state = newState; this.listeners.forEach(listener =\u0026gt; listener(this.state)); } }; // 컴포넌트가 스냅샷을 가져가기 위한 메서드 public getSnapshot = () =\u0026gt; { return this.state; }; } // 이 훅이 바로 마법의 핵심입니다. function useSelector\u0026lt;State, Slice\u0026gt;( store: Store\u0026lt;State\u0026gt;, selector: (state: State) =\u0026gt; Slice ) { const [slice, setSlice] = useState(() =\u0026gt; selector(store.getSnapshot())); useEffect(() =\u0026gt; { return store.subscribe(state =\u0026gt; { const newSlice = selector(state); if (newSlice !== slice) { setSlice(newSlice); } }); }, [store, selector, slice]); return slice; } 이것을 사용하기 위해 우리가 해야 할 일은 Store 인스턴스를 컨텍스트에 넣고, 모든 컴포넌트가 useSelector를 통해 스토어 업데이트를 구독하게 하는 것뿐입니다.\n‘선택자(selector)‘는 컴포넌트가 관심 있는 정확한 상태 조각을 선택하기 때문에, 그 조각이 변경되지 않는 한 리렌더링되지 않을 것입니다.\nconst StoreContext = createContext(); export function Grid() { // 스토어 인스턴스는 한 번만 생성됩니다. const [store] = useState(() =\u0026gt; new Store({ focus: 0 })); return ( \u0026lt;StoreContext.Provider value={store}\u0026gt; {Array.from({ length: 50 }).map((_, i) =\u0026gt; ( \u0026lt;Cell key={i} index={i} /\u0026gt; ))} \u0026lt;/StoreContext.Provider\u0026gt; ); } // 선택자 함수들 const selectors = { isFocused: (state, index) =\u0026gt; state.focus === index, }; function Cell({ index }) { const store = useContext(StoreContext); // 이제 전체 context가 아닌, \u0026#39;isFocused\u0026#39;라는 boolean 값만 구독합니다. const isFocused = useSelector(store, state =\u0026gt; selectors.isFocused(state, index) ); console.log(`Cell ${index} is rendering`); return ( \u0026lt;button onClick={() =\u0026gt; store.update({ ...store.getSnapshot(), focus: index })} className={isFocused ? \u0026#34;focus\u0026#34; : \u0026#34;\u0026#34;} \u0026gt; {index} \u0026lt;/button\u0026gt; ); } 이제 업데이트된 예제를 실행해 보세요.\n셀을 클릭하면, 포커스 상태가 변경된 두 개의 셀(‘이전 포커스 셀’과 ‘새로운 포커스 셀’)만 리렌더링되는 것을 확인할 수 있습니다.\n다른 모든 셀은 전혀 업데이트되지 않습니다.\n마치 각 셀에 필요한 정보만 콕 집어 문자 메시지로 보내주는 것과 같습니다.\n더 나아가기: 프로덕션을 위한 개선 이제 가장 미니멀한 해결책을 확립했으니, 고려해야 할 몇 가지 사항이 더 있습니다.\n1. React의 엣지 케이스: useSyncExternalStore 제가 위에서 제공한 useSelector 구현은 개념을 이해하는 데는 좋지만, 실제로는 ‘상태 찢어짐(state tearing)‘과 같은 엣지 케이스에 부딪힐 수 있습니다.\nReact 18에 도입된 비동기 렌더링 모델 때문에 발생하는 이 문제를 해결하기 위해, React는 외부 스토어를 구독하는 공식적인 방법인 useSyncExternalStore를 제공합니다.\n우리의 useSelector를 이 공식 훅을 사용하도록 업그레이드할 수 있습니다.\nimport { useSyncExternalStoreWithSelector } from \u0026#34;use-sync-external-store/with-selector\u0026#34;; function useSelector(store, selector, ...args) { return useSyncExternalStoreWithSelector( store.subscribe, store.getSnapshot, store.getSnapshot, // 서버 스냅샷 (여기서는 동일하게 사용) state =\u0026gt; selector(state, ...args) ); } 2. 더 인체공학적인 스토어 store.update({ ...store.getSnapshot(), focus: 42 })라고 쓰는 것은 장황합니다.\n스토어에 유틸리티 메서드를 추가하여 store.set(\u0026#39;focus\u0026#39;, 42)처럼 더 간단하게 쓸 수 있습니다.\nclass …","date":1752360488,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"3af5e4980c9694db406c43188c3e19cf","permalink":"http://localhost:1313/posts/2025-07-13-fine-grained-reactivity-is-easy/","publishdate":"2025-07-13T07:48:08+09:00","relpermalink":"/posts/2025-07-13-fine-grained-reactivity-is-easy/","section":"posts","summary":"React의 반응성은 정말 어려운 걸까요? Context API가 왜 불필요한 리렌더링을 유발하는지, 그리고 단 35줄의 코드로 Zustand와 같은 선택자 기반의 진정한 반응성을 구현하는 방법을 알아봅니다.","tags":["React","반응성","상태 관리","Context API","성능 최적화","Zustand","useSyncExternalStore"],"title":"React의 진짜 반응성 - 35줄 코드로 Context API의 함정 넘어서기","type":"posts"},{"authors":null,"categories":null,"content":"React와 함수형 프로그래밍 - 더 나은 코드를 위한 핵심 원칙 우리는 React의 내부 메커니즘, 모범 사례, 디자인 패턴, 그리고 고급 개념들을 탐구합니다.\n이 글들은 기본을 넘어 React가 내부적으로 어떻게 작동하는지 진정으로 이해하고자 하는 React 개발자들을 위해 작성되었습니다.\n서론: 함수형 프로그래밍이란 무엇인가? ‘함수형 프로그래밍(Functional Programming)‘은 계산을 ‘수학적 함수의 평가’로 취급하고, ‘상태 변경’과 ‘변경 가능한 데이터(mutable data)‘를 피하는 프로그래밍 접근 방식입니다.\n이는 많은 개발자에게 더 익숙한 전통적인 ‘명령형 프로그래밍’과는 크게 다릅니다.\n마치 누군가에게 식사를 준비하기 위해 상세한 단계별 지침을 주는 것(‘명령형’ 접근 방식)과, 재료와 적용할 변환 과정을 설명하는 레시피를 주는 것(‘함수형’ 접근 방식)의 차이를 생각해 보세요.\n함수형 프로그래밍에서 우리는 따라야 할 단계보다는 ‘데이터 변환’에 집중합니다.\n다른 패러다임과의 차이점 React에 특화된 함수형 개념에 뛰어들기 전에, 함수형 프로그래밍이 다른 패러다임과 어떻게 다른지 이해해 보겠습니다.\n‘명령형 프로그래밍’: 프로그램의 상태를 시간에 따라 변경함으로써 ‘어떻게’ 작업을 완수할지에 초점을 맞춥니다. // 명령형 접근 방식 let sum = 0; // 외부 상태 for (let i = 1; i \u0026lt;= 5; i++) { sum += i; // 상태를 직접 변경(mutate)합니다. } console.log(sum); // 15 ‘함수형 프로그래밍’: 데이터에 적용할 변환을 설명함으로써 ‘무엇을’ 완수할지에 초점을 맞춥니다. 상태 변경을 피하고 순수한 변환을 선호합니다. // 함수형 접근 방식 const numbers = [1, 2, 3, 4, 5]; const sum = numbers.reduce((acc, current) =\u0026gt; acc + current, 0); // 새로운 값을 반환합니다. console.log(sum); // 15 ‘객체 지향 프로그래밍(OOP)’: 데이터와 동작을 캡슐화하는 ‘객체’를 중심으로 코드를 구성합니다. 상태는 이 패러다임의 중심입니다. // 객체 지향 접근 방식 class Counter { constructor() { this.count = 0; // 상태(데이터)를 객체 내부에 캡슐화 } increment() { this.count += 1; // 객체 자신의 상태를 변경하는 메서드 return this.count; } } const counter = new Counter(); counter.increment(); // 객체의 내부 상태가 변경됨 React는 왜 함수형 프로그래밍을 선택했을까? React는 몇 가지 중요한 이유로 많은 함수형 프로그래밍 개념을 사용합니다.\n‘예측 가능성’: 순수 함수는 동일한 입력에 대해 항상 동일한 결과를 생성하므로, 컴포넌트의 동작이 더 예측 가능하고 디버깅하기 쉬워집니다. ‘테스트 용이성’: 부수 효과(side effects)가 없는 함수는 숨겨진 의존성이 없기 때문에 테스트하기가 더 쉽습니다. ‘합성(Composition)’: 작은 함수들을 결합하여 복잡한 동작을 만들 수 있는 것처럼, React 컴포넌트들을 합성하여 완전한 사용자 인터페이스를 만들 수 있습니다. ‘상태 관리’: 불변성(immutability)과 함수형 변환은 React가 변경 사항을 효율적으로 감지하고 렌더링 성능을 최적화할 수 있게 해줍니다. React는 순수 함수형 프로그래밍의 모든 측면을 엄격하게 따르지는 않더라도, 이러한 함수형 원칙들을 활용하여 더 예측 가능하고 유지보수하기 쉬운 프로그래밍 모델을 제공합니다.\n1. 일급 객체로서의 함수 (Functions as First-Class Values) JavaScript에서 함수는 ‘일급 객체’입니다.\n이는 함수가 언어의 다른 모든 값처럼 취급될 수 있음을 의미합니다.\n이 특징은 함수형 프로그래밍의 기본이며 React에서 널리 사용됩니다.\n실질적으로 이것은 JavaScript의 함수가 다음과 같은 일을 할 수 있다는 뜻입니다.\n변수에 할당되거나 자료 구조에 저장될 수 있습니다. 다른 함수에 인자로 전달될 수 있습니다. 다른 함수에 의해 반환될 수 있습니다. 이 유연성은 함수가 일급 객체가 아닌 언어에서는 어렵거나 불가능한 디자인 패턴을 가능하게 합니다.\n// 함수가 변수에 저장됩니다. const handleClick = () =\u0026gt; { console.log(\u0026#34;Button clicked\u0026#34;); }; // 함수가 prop으로 컴포넌트에 전달됩니다. function Button({ onClick, children }) { return \u0026lt;button onClick={onClick}\u0026gt;{children}\u0026lt;/button\u0026gt;; } function App() { return \u0026lt;Button onClick={handleClick}\u0026gt;Click here\u0026lt;/button\u0026gt;; } 2. 고차 컴포넌트 (Higher-Order Components, HOC) HOC는 React에서 일급 함수의 개념을 가장 강력하게 적용한 예시 중 하나입니다.\nHOC는 ‘컴포넌트를 인자로 받아, 새로운 기능이 추가된 새 컴포넌트를 반환하는 함수’입니다.\n이 기법은 컴포넌트 로직 재사용과 관심사 분리를 가능하게 합니다.\n‘Hooks’가 등장하기 전까지, HOC는 로직을 공유하는 가장 일반적인 방법이었습니다.\n// 로딩 상태를 추가하는 HOC function withLoading(Component) { // 새 컴포넌트를 반환합니다. return function WithLoadingComponent({ isLoading, ...props }) { if (isLoading) { return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;; } // 로딩이 아니면, 원본 컴포넌트를 렌더링합니다. return \u0026lt;Component {...props} /\u0026gt;; }; } // 기본 컴포넌트 function UserList({ users }) { return ( \u0026lt;ul\u0026gt; {users.map(user =\u0026gt; ( \u0026lt;li key={user.id}\u0026gt;{user.name}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ); } // 로딩 상태가 추가된 강화된 컴포넌트 생성 const UserListWithLoading = withLoading(UserList); // 사용 예시 function App() { const [users, setUsers] = useState([]); const [isLoading, setIsLoading] = useState(true); // ... useEffect로 데이터 페칭 return \u0026lt;UserListWithLoading isLoading={isLoading} users={users} /\u0026gt;; } HOC는 로직 재사용에 매우 강력하지만, 여러 개를 중첩하면 JSX가 복잡해지는 ‘래퍼 지옥(wrapper hell)‘이나 prop 이름 충돌 같은 단점도 있습니다.\n현대 React에서는 대부분의 경우 ‘커스텀 훅’이 더 나은 대안으로 여겨집니다.\n3. 순수 함수 (Pure Functions) 순수 함수는 함수형 프로그래밍의 핵심 개념입니다.\n순수 함수란:\n동일한 인자로 호출될 때 항상 동일한 결과를 반환합니다. 관찰 가능한 ‘부수 효과(side effects)‘가 없습니다. (외부 변수 수정, API 요청, console.log 등) 오직 자신의 인자에만 의존합니다. React에서는 컴포넌트가 그 props에 대해 순수 함수처럼 동작하도록 노력해야 합니다.\n동일한 props가 주어지면 항상 동일한 UI를 렌더링해야 하죠.\n이 원칙 덕분에 React는 렌더링을 최적화할 수 있습니다.\n만약 순수 컴포넌트의 props가 변경되지 않았다면, React는 결과가 동일할 것임을 알기 때문에 렌더링 과정을 건너뛸 수 있습니다. (React.memo가 바로 이 원리를 이용합니다.)\n// 순수 함수: 오직 매개변수에만 의존합니다. function calculateTotal(items) { return items.reduce((total, item) =\u0026gt; total + item.price * item.quantity, 0); } // 순수 React 컴포넌트: 동일한 items prop에 대해 항상 동일한 UI를 렌더링합니다. function OrderSummary({ items }) { const total = calculateTotal(items); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Total: ${total.toFixed(2)}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; ); } 4. 불변성 (Immutability) ‘불변성’은 기존 데이터를 직접 수정하지 않고, 대신 원하는 변경 사항이 적용된 ‘새로운 복사본’을 만드는 원칙입니다.\nReact에서 불변성이 중요한 이유는, React가 변경 사항을 감지하고 DOM을 언제 업데이트할지 결정하는 방식 때문입니다.\nReact는 객체의 ‘참조(reference)‘를 비교하여 무언가 변경되었는지 판단합니다.\n만약 객체를 직접 수정하면(mutation), 객체의 메모리 주소, 즉 참조는 그대로 유지됩니다.\nReact는 \u0026#39;이전 상태 === 새로운 상태\u0026#39; 인지 매우 빠른 참조 비교 검사를 수행하는데, 참조가 동일하면 아무것도 바뀌지 않았다고 착각하고 리렌더링을 건너뛰게 됩니다.\n불변성을 지키는 방법 (해야 할 것) function TodoList() { const [todos, setTodos] = useState([ /* ... */ ]); const toggleTodo = id =\u0026gt; { // map을 사용해 \u0026#39;새로운 배열\u0026#39;을 생성합니다. setTodos( todos.map(todo =\u0026gt; todo.id === id ? { ...todo, completed: !todo.completed } // 스프레드 연산자로 \u0026#39;새로운 객체\u0026#39;를 생성합니다. : todo ) ); }; // ... } 직접 수정하는 방법 (피해야 할 것) function TodoListBad() { const [todos, setTodos] = useState([ /* ... */ ]); // ❌ 나쁜 접근 방식 (직접 수정) const toggleTodoBad …","date":1752324091,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"ee327fafe0e379d6a184a52864fa083a","permalink":"http://localhost:1313/posts/2025-07-12-functional-programming-principles-in-react/","publishdate":"2025-07-12T12:41:31.76Z","relpermalink":"/posts/2025-07-12-functional-programming-principles-in-react/","section":"posts","summary":"React는 단순한 라이브러리가 아니라 사고방식입니다. 순수 함수, 불변성, 고차 컴포넌트, 컴포지션 등 함수형 프로그래밍의 핵심 원칙들이 어떻게 React를 더 예측 가능하고 강력하게 만드는지 깊이 있게 탐구합니다.","tags":["React","함수형 프로그래밍","순수 함수","불변성","고차 컴포넌트","컴포지션"],"title":"React와 함수형 프로그래밍 - 더 나은 코드를 위한 핵심 원칙","type":"posts"},{"authors":null,"categories":null,"content":"React와 React-DOM의 아키텍처 - 뇌와 손은 어떻게 분리되었나? 우리는 React의 내부 메커니즘, 모범 사례, 디자인 패턴, 그리고 고급 개념들을 탐구합니다.\n이 글들은 기본을 넘어 React가 내부적으로 어떻게 작동하는지 진정으로 이해하고자 하는 React 개발자들을 위해 작성되었습니다.\n서론: 두 개의 패키지, 하나의 철학 React는 ‘react’와 ‘react-dom’이라는 두 개의 개별 패키지로 나뉘어 있습니다.\n이 분리는 단순히 기술적인 선택이 아니라, React의 핵심적인 아키텍처 비전을 반영합니다.\n마치 인간의 신체처럼, React는 ‘생각하는 뇌’와 ‘실행하는 손’으로 역할을 명확히 나누고 있습니다.\n오늘은 이 두 패키지의 역할과 그 분리 뒤에 숨겨진 깊은 의미를 자세히 살펴보겠습니다.\nReact 패키지: 애플리케이션의 ‘뇌’ ‘react’ 패키지는 React 애플리케이션이 무엇인지를 정의하는 핵심 로직을 담고 있습니다.\n마치 모든 것을 계획하고 결정하는 ‘뇌’와 같습니다.\n컴포넌트, 엘리먼트, 상태를 생성하고 관리하는 모든 추상적인 작업이 바로 이곳에서 이루어집니다.\n구체적으로 이 패키지는 다음을 관리합니다.\n‘React 엘리먼트 생성’: 우리가 JSX로 작성한 코드를 바탕으로, 화면에 그려질 내용에 대한 ‘설계도’인 가상 DOM(React 엘리먼트 객체)을 만듭니다. ‘컴포넌트 시스템 관리’: 함수형 컴포넌트와 클래스 컴포넌트의 정의, props 전달 등 컴포넌트의 기본 구조를 관장합니다. ‘훅(Hooks)과 내부 로직’: useState, useEffect 등 훅의 모든 로직은 여기에 있습니다. 훅은 컴포넌트의 상태와 생명주기를 관리하는 ‘규칙’이므로, 특정 플랫폼에 종속되지 않습니다. ‘상태 관리와 컨텍스트’: 컴포넌트의 상태 변경을 추적하고, Context API를 통해 상태를 전파하는 모든 메커니즘을 포함합니다. 가장 중요한 점은 ‘react’ 패키지가 ‘플랫폼에 구애받지 않는다(platform-agnostic)‘는 것입니다.\n이 안에는 웹 브라우저의 DOM이나 모바일의 네이티브 UI에 대한 코드가 단 한 줄도 없습니다.\n오직 순수한 ‘무엇을(what)’ 렌더링할지에 대한 계획과 로직만 존재합니다.\n이 덕분에 React는 웹, 모바일, 데스크톱, 심지어 VR 애플리케이션까지 넘나들 수 있는 것입니다.\nReact-DOM 패키지: 브라우저를 위한 ‘손’ ‘react-dom’ 패키지는 ‘웹 브라우저’라는 특정 플랫폼을 위해 만들어졌습니다.\n이 패키지의 역할은 React라는 ‘뇌’가 만든 추상적인 세계(가상 DOM)와 실제 브라우저 DOM을 연결하는 ‘다리’이자, 그 계획을 실행하는 ‘손’입니다.\nReact의 지시를 실제 DOM 변경으로 바꾸는 모든 구체적인 작업이 이곳에서 이루어집니다.\n주요 책임은 다음과 같습니다.\n‘초기 DOM 렌더링 관리’: createRoot(document.getElementById(\u0026#39;root\u0026#39;))와 같이, React 애플리케이션을 실제 HTML 문서의 특정 지점에 처음으로 ‘장착(mount)‘시키는 역할을 합니다. ‘효율적인 DOM 업데이트’: 상태가 변경되었을 때, ‘뇌(react)‘로부터 변경 사항에 대한 지시를 받아, appendChild, setAttribute, removeChild 등 브라우저가 알아듣는 명령어로 실제 DOM을 최소한으로 조작합니다. ‘브라우저 이벤트 처리’: 우리가 JSX에 작성하는 onClick, onChange 같은 이벤트들을 처리합니다. 흥미롭게도, react-dom은 각 버튼마다 이벤트 리스너를 다는 대신, 애플리케이션 루트에 단 하나의 이벤트 리스너를 두고 ‘이벤트 위임(event delegation)‘을 통해 모든 이벤트를 효율적으로 관리합니다. 왜 두 개의 패키지로 분리했을까? 이 아키텍처 분리는 여러 가지 중요한 이점을 제공합니다.\n1. 이식성 (Portability) 이것이 가장 큰 이유입니다.\nReact의 ‘뇌’는 그대로 둔 채, ‘손’의 역할만 하는 ‘렌더러(Renderer)‘를 교체하면 다른 환경에서도 React를 사용할 수 있습니다.\n// 웹에서는 React-DOM 렌더러를 사용합니다. import { createRoot } from \u0026#34;react-dom/client\u0026#34;; const root = createRoot(document.getElementById(\u0026#34;root\u0026#34;)); root.render(\u0026lt;App /\u0026gt;); // 모바일에서는 React-Native 렌더러를 사용합니다. import { AppRegistry } from \u0026#34;react-native\u0026#34;; AppRegistry.registerComponent(\u0026#34;App\u0026#34;, () =\u0026gt; App); // 테스트 환경에서는 React-Test-Renderer를 사용합니다. import renderer from \u0026#34;react-test-renderer\u0026#34;; const tree = renderer.create(\u0026lt;App /\u0026gt;).toJSON(); 이 모든 환경에서 App 컴포넌트 자체는 동일하게 재사용될 수 있습니다.\n이것이 바로 React의 ‘한 번 배워서, 어디서든 작성한다(Learn Once, Write Anywhere)‘는 철학의 핵심입니다.\n2. 독립적인 유지보수 및 발전 각 패키지는 독립적으로 발전할 수 있습니다.\n예를 들어, React 팀은 브라우저 DOM의 변화와는 상관없이 새로운 훅(useOptimistic 등)을 ‘react’ 패키지에 추가할 수 있습니다.\n반대로, 브라우저에 새로운 API가 등장하면, ‘react-dom’ 팀은 React의 핵심 로직을 건드리지 않고도 렌더링 성능을 최적화할 수 있습니다.\n3. 최적화 및 번들 크기 이 분리는 번들 크기를 최적화하는 데 도움이 됩니다.\n예를 들어, 모바일 앱을 빌드할 때는 웹 브라우저의 DOM 조작과 관련된 react-dom의 방대한 코드를 포함할 필요가 전혀 없습니다.\nJSX 없이 React 사용해보기 이 분리 구조를 실제로 체감할 수 있는 재미있는 방법이 있습니다.\n바로 JSX 없이 React를 사용하는 것입니다.\n사실 JSX는 React.createElement() 함수를 더 편하게 쓰기 위한 ‘문법적 설탕(Syntactic Sugar)‘일 뿐입니다.\n// createElement와 useState는 \u0026#39;react\u0026#39; 패키지에서 옵니다. const { createElement, useState } = React; function Counter() { const [count, setCount] = useState(0); // 이 모든 것은 UI의 \u0026#39;설계도\u0026#39;를 만드는 과정입니다. return createElement(\u0026#34;div\u0026#34;, null, [ createElement(\u0026#34;p\u0026#34;, null, `Counter: ${count}`), createElement( \u0026#34;button\u0026#34;, { onClick: () =\u0026gt; setCount(count + 1) }, \u0026#34;Increment\u0026#34; ), createElement( \u0026#34;button\u0026#34;, { onClick: () =\u0026gt; setCount(count - 1) }, \u0026#34;Decrement\u0026#34; ), ]); } // createRoot와 render는 \u0026#39;react-dom\u0026#39; 패키지에서 옵니다. const root = ReactDOM.createRoot(document.getElementById(\u0026#34;root\u0026#34;)); // \u0026#39;뇌\u0026#39;가 만든 설계도(엘리먼트)를 \u0026#39;손\u0026#39;에게 전달하여 화면에 그리도록 명령합니다. root.render(createElement(Counter)); 솔직히 말해, 보기에 아주 장황한 코드죠! 😅 이것이 바로 우리가 JSX의 편리함에 감사해야 하는 이유입니다.\n결론 react와 react-dom의 분리 아키텍처는 훌륭한 설계가 어떻게 코드에 유연성과 유지보수성을 부여하는지 보여주는 완벽한 예시입니다.\n이 구조는 React가 다양한 환경에서 작동하게 하면서도, 코드베이스를 일관되고 최적화된 상태로 유지할 수 있게 해줍니다. 핵심을 다시 정리해 보겠습니다.\n‘React’는 ‘무엇을’ 할지 결정하는 ‘뇌’입니다. ‘React-DOM’은 브라우저에서 그 결정을 실행하는 ‘손’입니다. 이 분리 덕분에 React는 다른 플랫폼(모바일 등)에서도 작동할 수 있습니다. 각 플랫폼에 맞는 최적화를 가능하게 합니다. 서버 컴포넌트나 스트리밍 같은 현대적인 고급 기능을 지원하는 기반이 됩니다. 이 아키텍처는 React 19와 그 이후에도 계속해서 발전하며, React가 성공할 수 있었던 이유인 단순함과 유연성을 유지하면서 개발자들에게 더 많은 가능성을 열어줄 것입니다.\n","date":1752321290,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"3df3c2ccd2571114634b0a7c439c8c5d","permalink":"http://localhost:1313/posts/2025-07-12-react-and-react-dom-architecture-deep-dive/","publishdate":"2025-07-12T11:54:50.95Z","relpermalink":"/posts/2025-07-12-react-and-react-dom-architecture-deep-dive/","section":"posts","summary":"React가 왜 react와 react-dom 두 개의 패키지로 나뉘어 있는지, 그 심오한 설계 철학을 알아봅니다. 뇌 역할을 하는 React와 손 역할을 하는 React-DOM의 관계를 통해, 플랫폼에 구애받지 않는 React의 이식성과 미래를 탐구합니다.","tags":["React","React-DOM","React 아키텍처","렌더러","재조정","가상 DOM"],"title":"React와 React-DOM의 아키텍처 - 뇌와 손은 어떻게 분리되었나?","type":"posts"},{"authors":null,"categories":null,"content":"React Element 완전 정복 - 컴포넌트와 인스턴스는 무엇이 다른가? 우리는 React의 내부 메커니즘, 모범 사례, 디자인 패턴, 그리고 고급 개념들을 탐구합니다.\n이 글들은 기본을 넘어 React가 내부적으로 어떻게 작동하는지 진정으로 이해하고자 하는 React 개발자들을 위해 작성되었습니다.\n들어가기 전에: 엘리먼트, 컴포넌트, 인스턴스 React를 배울 때 많은 개발자들이 이 세 가지 용어를 혼용하곤 합니다.\n하지만 이들을 명확히 구분하는 것이 오늘 이야기의 핵심입니다.\n‘컴포넌트(Component)’: 컴포넌트는 ‘설계도’ 또는 ‘레시피’입니다. 함수나 클래스 형태로 존재하며, UI를 어떻게 만들어야 하는지에 대한 로직을 담고 있습니다. 그 자체로는 화면에 아무것도 그리지 않습니다. ‘엘리먼트(Element)’: 엘리먼트는 ‘주문서’ 또는 ‘계획’입니다. { type: \u0026#39;div\u0026#39;, props: { ... } } 와 같은 형태의, 화면에 그려질 내용을 설명하는 평범한 자바스크립트 ‘객체(Object)‘입니다. 매우 가볍고, 상태를 가지지 않으며, 불변(immutable)합니다. ‘인스턴스(Instance)’: 인스턴스는 컴포넌트라는 설계도를 바탕으로 만들어진 ‘실체’입니다. 클래스 컴포넌트에서 this가 가리키는 대상이며, 자신만의 상태(state)와 생명주기(lifecycle)를 갖는, 살아있는 존재입니다. 우리가 JSX로 코드를 작성할 때, React는 이 코드를 바탕으로 ‘엘리먼트’라는 객체를 만들고, 이 엘리먼트 정보를 이용해 화면을 그리고 컴포넌트의 ‘인스턴스’를 관리합니다.\n오늘의 주인공은 바로 이 ‘엘리먼트’입니다.\nReact 엘리먼트란 무엇일까? ‘React 엘리먼트’는 사용자 인터페이스의 한 노드를 설명하는 단순한 자바스크립트 객체입니다.\nReact를 구성하는 가장 작은 벽돌이죠.\n그 구조를 살펴보겠습니다.\n// React 엘리먼트의 기본 구조 { $$typeof: Symbol.for(\u0026#39;react.element\u0026#39;), type: \u0026#39;div\u0026#39;, key: null, ref: null, props: { children: \u0026#39;Hello World\u0026#39; } } 각 속성을 하나씩 분석해 보겠습니다.\n$$typeof 속성 $$typeof: Symbol.for(\u0026#34;react.element\u0026#34;);\n이 속성은 React가 다른 자바스크립트 객체와 React 엘리먼트를 구분하기 위해 사용하는 내부 서명입니다.\n이것은 단순한 식별자를 넘어 중요한 ‘보안’ 장치 역할을 합니다.\n만약 서버에서 악의적인 JSON 데이터를 받아 그대로 렌더링하려고 할 때, React는 이 $$typeof 속성이 있는지 확인합니다.\n이 특별한 심볼이 없다면, React는 그것을 엘리먼트로 취급하지 않아 XSS(Cross-Site Scripting) 공격을 방지할 수 있습니다.\n우리가 코드에서 직접 다룰 일은 거의 없는 내부 메커니즘입니다.\ntype 속성 type은 해당 엘리먼트의 본질을 결정합니다.\n// 1. 네이티브 HTML 엘리먼트의 경우 (문자열) { type: \u0026#34;div\u0026#34;; } // 또는 \u0026#39;span\u0026#39;, \u0026#39;p\u0026#39; 등 // 2. React 컴포넌트의 경우 (함수 또는 클래스에 대한 참조) { type: MyComponent; } // 3. Fragment의 경우 (심볼) { type: Symbol.for(\u0026#34;react.fragment\u0026#34;); } props 속성 props는 엘리먼트의 모든 데이터와 콘텐츠를 담고 있습니다.\n{ type: \u0026#39;button\u0026#39;, props: { className: \u0026#39;btn\u0026#39;, onClick: () =\u0026gt; console.log(\u0026#39;click\u0026#39;), children: \u0026#39;Click me\u0026#39; } } 특별한 children prop은 여러 형태를 가질 수 있습니다.\n// 1. 단순한 문자열 { props: { children: \u0026#39;Simple text\u0026#39; } } // 2. 또 다른 React 엘리먼트 { props: { children: { type: \u0026#39;span\u0026#39;, props: { children: \u0026#39;Text in span\u0026#39; } } } } // 3. 엘리먼트 배열 { props: { children: [ { type: \u0026#39;li\u0026#39;, props: { children: \u0026#39;1\u0026#39; } }, { type: \u0026#39;li\u0026#39;, props: { children: \u0026#39;2\u0026#39; } } ] } } key와 ref 속성 { key: \u0026#39;unique-id\u0026#39;, // 리스트 재조정(reconciliation)에 사용됩니다. ref: null // DOM 엘리먼트나 컴포넌트에 대한 참조를 담을 수 있습니다. } React는 어떻게 이 엘리먼트들을 만들까? 우리가 JSX를 작성할 때:\nconst element = \u0026lt;div className=\u0026#34;container\u0026#34;\u0026gt;Hello\u0026lt;/div\u0026gt;; Babel과 같은 트랜스파일러는 이 코드를 React.createElement 함수 호출로 변환합니다.\nconst element = React.createElement(\u0026#34;div\u0026#34;, { className: \u0026#34;container\u0026#34; }, \u0026#34;Hello\u0026#34;); 그러면 React.createElement 함수가 앞서 본 완전한 ‘React 엘리먼트’ 객체를 만들어냅니다.\nReact.createElement 함수의 의사 코드는 다음과 같습니다.\n// React.createElement의 단순화된 의사 코드 function createElement(type, config, children) { // 특별한 props 추출 let key = config?.key || null; let ref = config?.ref || null; // props 빌드 const props = {}; for (let propName in config) { if ( hasOwnProperty.call(config, propName) \u0026amp;\u0026amp; propName !== \u0026#34;key\u0026#34; \u0026amp;\u0026amp; propName !== \u0026#34;ref\u0026#34; ) { props[propName] = config[propName]; } } // 자식들(children) 처리 const childrenLength = arguments.length - 2; if (childrenLength === 1) { props.children = children; } else if (childrenLength \u0026gt; 1) { props.children = Array.prototype.slice.call(arguments, 2); } // 엘리먼트 객체 빌드 return { $$typeof: Symbol.for(\u0026#34;react.element\u0026#34;), type, key, ref, props, }; } 엘리먼트 재조정(Reconciliation) ‘재조정’은 React가 두 개의 React 엘리먼트 트리를 비교하여 DOM에 어떤 변경 사항을 적용할지 결정하는 과정입니다.\n이것이 바로 React의 ‘가상 DOM(Virtual DOM)‘이 동작하는 핵심 원리입니다.\nReact는 마치 ‘틀린 그림 찾기’를 하듯, 이전 엘리먼트 트리와 새로운 엘리먼트 트리를 비교합니다.\n비교 과정 React는 엘리먼트를 재귀적으로 비교합니다.\n타입이 다른 경우: 이전 트리를 완전히 파괴하고 새로운 트리를 만듭니다. (예: \u0026lt;div\u0026gt;가 \u0026lt;span\u0026gt;으로 변경된 경우) 타입이 같은 경우: 속성만 비교하여 변경된 부분(예: className)만 업데이트합니다. 리스트의 경우: key prop을 사용하여 어떤 엘리먼트가 이동했는지, 추가되었는지, 또는 삭제되었는지 식별합니다. key의 중요성 key는 React가 리스트의 각 엘리먼트를 고유하게 식별하도록 돕는 가장 중요한 단서입니다.\n‘key가 없다면’: React는 엘리먼트들이 재정렬되었는지, 아니면 완전히 교체되었는지 알 수 없습니다. 예를 들어 리스트의 맨 앞에 아이템을 추가하면, React는 모든 리스트 아이템이 변경되었다고 착각하여 모든 DOM 노드를 파괴하고 새로 만들 수 있습니다. 이는 성능 저하뿐만 아니라, 각 아이템이 가지고 있던 내부 상태(예: \u0026lt;input\u0026gt;의 입력값)가 사라지는 문제를 유발합니다. ‘key가 있다면’: React는 key를 통해 “아, ‘b’ 아이템이 ‘a’ 아이템 앞으로 이동했구나\u0026#34;라고 정확히 파악하고, DOM 노드를 파괴하는 대신 순서만 변경합니다. 이처럼 영리한 재조정 과정 덕분에 React는 DOM 조작을 최소화하고, 복잡한 인터페이스에서도 뛰어난 성능을 제공할 수 있습니다.\n결론 React 엘리먼트를 이해하는 것은 모든 React 개발자에게 매우 중요합니다.\n이 단순한 자바스크립트 객체는 React 세계의 모든 것을 이루는 기초입니다.\n그것이 어떻게 작동하고 React가 어떻게 사용하는지 알게 됨으로써, 여러분은 다음을 더 잘 이해할 수 있습니다.\nJSX가 어떻게 이 객체들로 변환되는가 React가 리스트에 고유한 key를 필요로 하는 이유 React가 재조정을 통해 어떻게 효율적으로 DOM을 업데이트하는가 복잡한 React 애플리케이션조차도 이 기본적인 빌딩 블록들로 만들어진다는 것을 기억하세요. 대부분의 경우 React 엘리먼트를 직접 다룰 필요는 없지만, 그 구조를 이해하는 것은 여러분이 더 나은 React 코드를 작성하는 데 큰 도움이 될 것입니다. ","date":1752234671,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"f0c6c025a252cc751163ad281b40f4c9","permalink":"http://localhost:1313/posts/2025-07-11-react-element-deep-dive/","publishdate":"2025-07-11T11:51:11.746Z","relpermalink":"/posts/2025-07-11-react-element-deep-dive/","section":"posts","summary":"React의 가장 작은 벽돌, React Element의 모든 것을 알아봅니다. JSX가 어떻게 평범한 자바스크립트 객체로 변환되는지, 그리고 재조정(Reconciliation) 과정에서 엘리먼트와 key가 어떻게 동작하는지 깊이 있게 탐구합니다.","tags":["React Element","JSX","React 컴포넌트","재조정","Reconciliation","가상 DOM"],"title":"React Element 완전 정복 - 컴포넌트와 인스턴스는 무엇이 다른가?","type":"posts"},{"authors":null,"categories":null,"content":"React 개발자 레벨업 - 명령형 vs 선언형, 당신은 어떻게 코딩하고 있나요? 더 나은 React 개발자가 되기 위해서는, 코드를 작성하는 두 가지 다른 방식을 대표하는 이 두 프로그래밍 패러다임을 이해하는 것이 필수적입니다.\nReact를 잘 다루는 것은 단순히 문법을 아는 것을 넘어, ‘생각하는 방식’을 바꾸는 것이기 때문입니다.\n오늘은 이 두 패러다임이 무엇이며, React가 왜 그중 하나를 핵심 철학으로 삼았는지 알아보겠습니다.\n1. 명령형 프로그래밍: ‘어떻게’에 집중하는 방식 ‘명령형(Imperative) 프로그래밍’은 원하는 결과를 얻기 위해 필요한 행동들을 단계별로 상세하게 서술하는 방식에 초점을 맞춥니다.\n마치 요리를 처음 하는 사람에게 “1. 감자를 씻으세요. 2. 껍질을 벗기세요. 3. 2cm 크기로 자르세요…” 라고 하나하나 지시하는 것과 같습니다.\n코드로 구체적인 예시를 살펴보겠습니다.\n예시 1: 배열 필터링하고 변환하기 const numbers = [1, 2, 3, 4, 5, 6]; const result = []; // 우리는 각 단계를 직접 서술합니다. for (let i = 0; i \u0026lt; numbers.length; i++) { // 1단계: 짝수인지 확인한다. if (numbers[i] % 2 === 0) { // 2단계: 2를 곱해서 결과 배열에 넣는다. result.push(numbers[i] * 2); } } // result = [4, 8, 12] for 루프를 돌고, if 조건문으로 확인하고, push로 직접 배열을 조작하는 모든 과정, 즉 ‘어떻게’ 할지에 대한 모든 세부 사항을 직접 지시하고 있습니다.\n예시 2: 순수 JavaScript로 DOM 조작하기 이 패러다임은 jQuery나 순수 JavaScript로 UI를 만들 때 더욱 명확하게 드러납니다.\n// 1. \u0026#39;ul\u0026#39; 요소를 만든다. const list = document.createElement(\u0026#34;ul\u0026#34;); const items = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;]; items.forEach(item =\u0026gt; { // 2. 각 아이템에 대해 \u0026#39;li\u0026#39; 요소를 만든다. const li = document.createElement(\u0026#34;li\u0026#34;); // 3. 텍스트를 설정한다. li.textContent = item; // 4. 클래스 이름을 붙인다. li.className = \u0026#34;fruit-item\u0026#34;; // 5. \u0026#39;ul\u0026#39;에 \u0026#39;li\u0026#39;를 자식으로 추가한다. list.appendChild(li); }); // 6. 마지막으로 body에 \u0026#39;ul\u0026#39;을 추가한다. document.body.appendChild(list); 상태가 복잡해지면 이 모든 단계를 추적하고 관리하는 것은 금세 악몽이 됩니다.\n특정 아이템을 삭제하거나 수정하려면, DOM에서 해당 요소를 직접 찾아내고, 제거하고, 다시 추가하는 복잡한 명령을 내려야 합니다.\n2. 선언형 프로그래밍: ‘무엇’에 집중하는 방식 ‘선언형(Declarative) 프로그래밍’은 ‘어떻게’가 아닌 ‘무엇’에 초점을 맞춥니다.\n우리는 원하는 결과가 무엇인지만 서술하고, 시스템이 그 구현 세부 사항을 처리하도록 맡깁니다.\n마치 레스토랑에서 “페퍼로니 피자 한 판 주세요\u0026#34;라고 주문하는 것과 같습니다.\n주방에서 도우를 어떻게 펴고, 소스를 어떻게 바르고, 몇 도에서 굽는지는 신경 쓸 필요가 없습니다.\n그저 ‘페퍼로니 피자’라는 결과물만 받으면 됩니다.\n같은 예시를 선언형 방식으로 보겠습니다.\n예시 1: 배열 필터링하고 변환하기 const numbers = [1, 2, 3, 4, 5, 6]; // \u0026#34;숫자들 중에서 짝수인 것만 골라서, 각각 2를 곱한 결과를 원해\u0026#34; const result = numbers.filter(num =\u0026gt; num % 2 === 0).map(num =\u0026gt; num * 2); // result = [4, 8, 12] for 루프도, 임시 배열도 없습니다.\n우리는 단지 ‘무엇을’ 원하는지만 filter와 map 같은 고차 함수를 통해 선언했습니다.\n그 ‘어떻게’는 JavaScript 엔진이 알아서 처리합니다.\n예시 2: JSX (React) 이 패러다임의 정수가 바로 React의 JSX입니다.\nfunction FruitList() { const items = [\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Orange\u0026#34;]; // \u0026#34;나는 이런 모양의 리스트를 원해\u0026#34; return ( \u0026lt;ul\u0026gt; {items.map(item =\u0026gt; ( \u0026lt;li className=\u0026#34;fruit-item\u0026#34; key={item}\u0026gt; {item} \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ); } createElement, appendChild 같은 명령형 코드는 어디에도 없습니다.\n우리는 그저 최종적으로 화면에 그려지길 원하는 UI의 ‘모습’을 선언했을 뿐입니다.\n나머지 복잡한 DOM 조작은 React가 알아서 처리해 줍니다.\nReact와 선언형 프로그래밍 심층 탐구 React는 철저하게 선언형 프로그래밍 패러다임을 따릅니다.\nReact의 여러 측면을 통해 이 패러다임이 어떻게 적용되는지 살펴보겠습니다.\n상태 관리 (useState) function Counter() { const [count, setCount] = useState(0); // \u0026#34;버튼을 클릭하면, count 상태가 현재 count + 1이 되어야 해\u0026#34; 라고 선언합니다. return \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;Counter: {count}\u0026lt;/button\u0026gt;; } 우리는 useState로 상태를 ‘선언’하고, 그것이 어떻게 변경되어야 하는지만 서술합니다.\nsetCount가 호출된 이후에 React가 어떤 과정을 거쳐 DOM을 업데이트하고, 이벤트를 처리하고, 변수의 생명주기를 관리하는지에 대해서는 전혀 걱정할 필요가 없습니다.\n조건부 렌더링 function Message({ isLoggedIn }) { return ( \u0026lt;div\u0026gt; {/* \u0026#34;isLoggedIn이 참이면 이 메시지를, 거짓이면 저 메시지를 보여줘\u0026#34; */} {isLoggedIn ? \u0026lt;h1\u0026gt;Welcome to your account\u0026lt;/h1\u0026gt; : \u0026lt;h1\u0026gt;Please log in\u0026lt;/h1\u0026gt;} \u0026lt;/div\u0026gt; ); } React의 조건부 렌더링은 선언적입니다.\n우리는 가능한 상태들을 서술하기만 하면, React가 올바른 콘텐츠를 보여주는 것을 처리합니다.\nDOM을 수동으로 처리할 필요가 없습니다.\n이펙트 관리 (useEffect) useEffect 훅은 React의 선언적 접근 방식을 완벽하게 보여줍니다.\nfunction ResizeMessage() { const [windowWidth, setWindowWidth] = useState(window.innerWidth); useEffect(() =\u0026gt; { // 1. \u0026#34;무엇을 해야 하는지\u0026#34; 선언: 창 크기 조절을 감지해야 해. const handleResize = () =\u0026gt; { setWindowWidth(window.innerWidth); }; window.addEventListener(\u0026#34;resize\u0026#34;, handleResize); // 2. \u0026#34;어떻게 정리해야 하는지\u0026#34; 선언: 컴포넌트가 사라지면 이벤트 리스너를 제거해야 해. return () =\u0026gt; window.removeEventListener(\u0026#34;resize\u0026#34;, handleResize); }, []); // 이 효과는 한 번만 실행되도록 선언합니다. return \u0026lt;p\u0026gt;Window width: {windowWidth}px\u0026lt;/p\u0026gt;; } 우리는 ‘이벤트 리스너를 추가해야 한다’는 것과 ‘정리해야 한다’는 사실만 선언합니다.\nReact는 이 이펙트의 생명주기를 자동으로 관리하여, 컴포넌트가 마운트될 때 실행하고 언마운트될 때 정리합니다.\n선언형 세계의 예외: 명령형이 필요할 때 (useRef) 그렇다면 React에서는 명령형 코드를 절대 사용할 수 없을까요? 아닙니다.\n때로는 특정 DOM 노드에 직접 접근하여 명령을 내려야 할 때가 있습니다. (예: 특정 input에 포커스 주기, 스크롤 위치 제어하기, 애니메이션 직접 실행하기 등)\n이럴 때를 위해 React는 useRef라는 ‘탈출구(escape hatch)‘를 제공합니다.\nfunction TextInputWithFocusButton() { const inputEl = useRef(null); const onButtonClick = () =\u0026gt; { // \u0026#39;inputEl.current\u0026#39;는 실제 input DOM 노드를 가리킵니다. // DOM 노드에 직접 \u0026#39;focus()\u0026#39;라는 명령을 내립니다. inputEl.current.focus(); }; return ( \u0026lt;\u0026gt; \u0026lt;input ref={inputEl} type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button onClick={onButtonClick}\u0026gt;Focus the input\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } useRef는 선언형으로 관리되는 React의 상태 흐름에 영향을 주지 않으면서, 필요할 때만 DOM에 직접적인 명령을 내릴 수 있게 해주는 다리 역할을 합니다.\n결론 선언형 프로그래밍은 우리가 애플리케이션을 작성하는 방식을 바꾸는 React의 핵심 개념입니다.\n이 접근 방식은 우리가 거기에 도달하기 위한 단계 대신 최종 결과에 집중할 수 있게 해줍니다.\n우리의 예제를 통해, 우리는 React가 모든 수준에서 이 패러다임을 어떻게 적용하는지 보았습니다.\n상태 관리는 간단한 데이터 선언이 됩니다. 조건부 렌더링은 각 가능한 경우를 서술하는 것뿐입니다. 리스트 처리는 데이터 변환으로 자연스럽게 이루어집니다. 부수 효과는 예측 가능하고 통제된 방식으로 관리됩니다. 이 선언적 접근 방식은 우리 코드를 더 예측 가능하고, 유지보수 및 테스트하기 쉽게 만듭니다.\nReact를 배운다는 것은 결국 명령형 사고에서 선언형 사고로 전환하는 과정이며, 이 전환을 완전히 이해했을 때 비로소 우리는 복잡한 인터페이스를 만들면서도 코드를 명확하고 구조적으로 유지할 수 있게 될 것입니다.\n","date":1752148108,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"298996969e418898b5225eac63f310a2","permalink":"http://localhost:1313/posts/2025-07-10-react-declarative-vs-imperative-programming-mindset/","publishdate":"2025-07-10T11:48:28.564Z","relpermalink":"/posts/2025-07-10-react-declarative-vs-imperative-programming-mindset/","section":"posts","summary":"더 나은 React 개발자가 되기 위한 필수 개념, 명령형과 선언형 프로그래밍을 알아봅니다. React가 왜 선언형 패러다임을 선택했는지, 그리고 언제 명령형 접근이 필요한지 useRef 예제와 함께 깊이 있게 탐구합니다.","tags":["React","선언형 프로그래밍","명령형 프로그래밍","리액트 사고방식","useState","useEffect"],"title":"React 개발자 레벨업 - 명령형 vs 선언형, 당신은 어떻게 코딩하고 있나요?","type":"posts"},{"authors":null,"categories":null,"content":"CORS 에러, 더 이상 두렵지 않다 (완전 정복 가이드) 프론트엔드에서 API 요청을 보냈을 때, 브라우저 콘솔에 떠오르는 붉은색의 “Cross-Origin Request Blocked” 에러 메시지를 마주하고 좌절해 본 적이 있으신가요?\n이 문제는 대부분 ‘Cross-Origin Resource Sharing’, 즉 CORS에 대한 이해 부족에서 비롯됩니다.\n저 역시 몇 년 전에는 같은 배를 타고 있었습니다.\n결국 CORS를 더 깊이 파고들기 위해 CakePHP 플러그인을 만들기로 결심하기까지 했죠.\n오늘은 그 경험을 바탕으로 CORS가 무엇이고 어떻게 동작하는지, 그 근본 원리부터 함께 파헤쳐 보겠습니다.\n1. 문제의 근원: ‘동일 출처 정책(Same-Origin Policy, SOP)’ CORS를 이해하려면, 먼저 웹 브라우저의 가장 근본적인 보안 원칙인 ‘동일 출처 정책’부터 알아야 합니다.\n‘출처(Origin)‘란 프로토콜(http/https), 도메인(example.com), 포트(:80)의 조합을 의미합니다.\n이 세 가지가 모두 같아야 ‘동일 출처’로 인정됩니다.\n‘동일 출처 정책’이란, **‘한 출처에서 로드된 문서나 스크립트는 다른 출처의 리소스와 상호작용할 수 없다’**는 규칙입니다.\n마치 아파트 보안 시스템과 같습니다.\n여러분의 집(https://mydomain.com) 안에서는 자유롭게 물건을 옮길 수 있지만, 옆 동 아파트(https://api.another.com)에 허락 없이 들어가 물건을 가져올 수는 없는 것과 같은 이치입니다.\n이 정책 덕분에, 악의적인 웹사이트가 여러분이 로그인해 둔 은행 사이트나 이메일에 멋대로 요청을 보내 데이터를 훔쳐보는 끔찍한 일을 방지할 수 있습니다.\n2. 해결책의 등장: ‘CORS’ 하지만 현대 웹 애플리케이션은 여러 도메인에 걸쳐 분산된 서비스(예: 프론트엔드 서버와 API 서버)가 서로 통신해야 하는 경우가 많습니다.\nSOP를 무조건 지키면 이런 아키텍처는 불가능하겠죠.\n‘CORS(Cross-Origin Resource Sharing)‘는 바로 이 문제를 해결하기 위해 등장한 메커니즘입니다.\nCORS는 서버가 특정 출처의 요청을 허용하도록 명시적인 ‘허락’을 내릴 수 있게 해주는 HTTP 헤더 기반의 체계입니다.\n즉, 옆 동 아파트의 집주인(서버)이 “아, mydomain.com에서 온 요청은 괜찮으니 들여보내 주세요\u0026#34;라고 경비원(브라우저)에게 미리 말해주는 것과 같습니다.\n만약 https://mydomain.com에서 https://google.com으로 요청을 보내면, 구글 서버는 mydomain.com을 허용하지 않았으므로 브라우저는 다음과 같은 에러를 보여줍니다.\nAccess to fetch at ‘https://www.google.com/\u0026#39; from origin ‘https://mydomain.com’ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.\n이는 “구글 서버 응답에 ‘Access-Control-Allow-Origin’ 헤더가 없어서, 우리 브라우저 보안 정책상 이 요청을 차단했습니다\u0026#34;라는 의미입니다.\n‘중요한 사실’: CORS는 서버를 보호하는 기술이 아니라, 사용자의 브라우저를 보호하는 기술입니다.\n따라서 curl이나 Postman 같은 도구로 API를 직접 호출하면 CORS 에러가 발생하지 않습니다.\n오직 브라우저만이 이 정책을 강제합니다.\n3. CORS는 어떻게 동작할까? (통신 흐름) CORS는 요청의 종류에 따라 두 가지 방식으로 동작합니다: ‘단순 요청(Simple Requests)‘과 ‘프리플라이트 요청(Preflight Requests)’.\n단순 요청 (Simple Request) 아래의 특정 조건을 모두 만족하는 요청은 ‘단순 요청’으로 분류되어, 브라우저는 별도의 확인 절차 없이 바로 본 요청을 보냅니다.\n메서드: GET, HEAD, POST 중 하나 헤더: 기본 헤더 외에 Accept, Accept-Language, Content-Language, Content-Type만 허용 (단, Content-Type은 application/x-www-form-urlencoded, multipart/form-data, text/plain 값만 가능) 단순 요청의 흐름:\n클라이언트 (브라우저) → 서버: Origin: https://mydomain.com 헤더를 포함하여 실제 요청을 보냅니다. 서버 → 클라이언트: Access-Control-Allow-Origin: https://mydomain.com (또는 *) 헤더를 포함하여 응답합니다. 클라이언트 (브라우저): 응답 헤더의 Access-Control-Allow-Origin 값을 보고, 현재 출처가 허용되었는지 확인합니다. 허용되었다면 요청을 성공 처리하고, 그렇지 않다면 CORS 에러를 발생시킵니다. 프리플라이트 요청 (Preflight Request) ‘단순 요청’의 조건을 벗어나는 복잡한 요청(예: PUT, DELETE 메서드, Content-Type: application/json, 커스텀 헤더 포함 등)은 브라우저가 본 요청을 보내기 전에 먼저 ‘프리플라이트(preflight, 사전 확인)’ 요청을 보냅니다.\n이 프리플라이트 요청은 OPTIONS 메서드를 사용하며, “제가 잠시 후에 이런이런 메서드와 헤더로 본 요청을 보낼 건데, 괜찮을까요?“라고 서버에 미리 물어보는 역할을 합니다.\n프리플라이트 요청의 흐름:\n클라이언트 (브라우저) → 서버: OPTIONS 메서드로 프리플라이트 요청을 보냅니다. 이 요청에는 Access-Control-Request-Method (실제 요청의 메서드), Access-Control-Request-Headers (실제 요청의 헤더) 같은 정보가 담겨 있습니다. 서버 → 클라이언트: 이 서버가 허용하는 정책을 담은 헤더들로 응답합니다. (Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers 등) 클라이언트 (브라우저): 서버의 응답을 보고, 자신이 보내려던 본 요청이 허용되는지 확인합니다. (허용된 경우) → 서버: 이제서야 실제 PUT 이나 DELETE 같은 본 요청을 보냅니다. 서버 → 클라이언트: 본 요청에 대한 실제 응답을 보냅니다. 이처럼 두 번의 통신이 일어나기 때문에, 프리플라이트 요청은 약간의 성능 저하를 유발할 수 있습니다.\n이를 완화하기 위해 서버는 Access-Control-Max-Age 헤더를 사용하여 프리플라이트 응답을 특정 시간 동안 브라우저에 캐시하도록 할 수 있습니다.\n4. 서버와 클라이언트 구현 예제 서버 측 설정 (Express.js) 실제 서버에서는 cors 같은 라이브러리를 사용하면 편리하게 CORS 헤더를 설정할 수 있습니다.\nconst express = require(\u0026#34;express\u0026#34;); const cors = require(\u0026#34;cors\u0026#34;); const app = express(); // CORS 설정을 구성합니다. app.use( cors({ origin: \u0026#34;https://example.com\u0026#34;, // Access-Control-Allow-Origin: 허용할 출처 methods: \u0026#34;GET, POST, PUT, DELETE\u0026#34;, // Access-Control-Allow-Methods: 허용할 메서드 allowedHeaders: \u0026#34;Content-Type, Authorization\u0026#34;, // Access-Control-Allow-Headers: 허용할 헤더 credentials: true, // Access-Control-Allow-Credentials: 쿠키 등 자격 증명 허용 }) ); // ... 나머지 API 라우트 클라이언트 측 구현 (fetch) fetch API를 사용할 때, CORS는 브라우저가 자동으로 처리합니다.\n다만, 쿠키나 인증 토큰 같은 ‘자격 증명(credentials)‘을 함께 보내야 할 경우, credentials: \u0026#39;include\u0026#39; 옵션을 명시해야 합니다.\nfetch(\u0026#34;https://api.example.com/data\u0026#34;, { method: \u0026#34;GET\u0026#34;, credentials: \u0026#34;include\u0026#34;, // 세션 쿠키 등을 함께 보내기 위해 필요합니다. }).then(response =\u0026gt; { // ... }); 5. 흔한 CORS 에러와 해결책 이제 개발자들이 가장 고통받는 부분, 바로 에러 메시지별 해결책입니다.\n에러 1: “No ‘Access-Control-Allow-Origin’ header” ‘원인’: 가장 흔한 에러로, 서버 응답에 이 헤더가 아예 없는 경우입니다. 브라우저는 허락의 증표를 찾지 못했으므로 요청을 차단합니다. ‘해결책’: 서버에서 Access-Control-Allow-Origin 헤더에 요청을 보낸 출처(예: https://example.com)나 모든 출처를 허용하는 *를 포함하여 응답하도록 설정합니다.\n에러 2: “The value of the ‘Access-Control-Allow-Origin’ header … must not be the wildcard ‘*’ when the credentials flag is true.” ‘원인’: 요청에 credentials: \u0026#39;include\u0026#39; 옵션이 있는데, 서버가 Access-Control-Allow-Origin: *로 응답한 경우입니다. 보안상의 이유로, 자격 증명이 포함된 요청에는 모든 출처를 허용하는 와일드카드(*)를 사용할 수 없습니다. ‘해결책’: * 대신, 요청을 허용할 정확한 출처(예: https://example.com)를 명시해야 합니다.\n에러 3: “Response to preflight request doesn’t pass access control check: It does not have HTTP ok status.” ‘원인’: 프리플라이트 OPTIONS 요청에 대해 서버가 200번대의 성공적인 HTTP 상태 코드로 응답하지 않은 경우입니다. 서버가 OPTIONS …","date":1752061390,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"16c18febca38c5a150f016fa4ab3bdfa","permalink":"http://localhost:1313/posts/2025-07-09-complete-guide-to-understanding-cors/","publishdate":"2025-07-09T11:43:10.519Z","relpermalink":"/posts/2025-07-09-complete-guide-to-understanding-cors/","section":"posts","summary":"Cross-Origin Request Blocked 에러의 정체는 무엇일까요? 웹 보안의 핵심인 동일 출처 정책부터 CORS 헤더, 프리플라이트 요청의 흐름, 그리고 흔한 에러 해결법까지, CORS의 모든 것을 알아봅니다.","tags":["CORS","동일 출처 정책","SOP","Cross-Origin","프리플라이트","웹 보안"],"title":"CORS 에러, 더 이상 두렵지 않다 (완전 정복 가이드)","type":"posts"},{"authors":null,"categories":null,"content":"React 18의 숨겨진 보석, useSyncExternalStore 완벽 가이드 (feat. LocalStorage) React 애플리케이션을 개발하다 보면, 애플리케이션 상태를 외부 데이터 소스와 동기화해야 할 필요가 종종 생깁니다.\n특히 사용자의 테마 설정이나 장바구니 정보처럼, 브라우저 세션 간에 유지되어야 하는 데이터를 ‘LocalStorage’에 저장하는 경우가 대표적이죠.\nReact 18부터는 이러한 동기화를 원활하게 처리하기 위해 useSyncExternalStore라는 새로운 훅이 도입되었습니다.\n오늘은 이 강력한 훅을 사용하는 구체적인 예제를 통해 그 사용법을 깊이 있게 알아보겠습니다.\n왜 useSyncExternalStore를 사용해야 할까요? 이 훅의 이름을 직역하면 ‘외부 저장소의 상태를 동기화하는 데 사용한다’는 의미입니다.\n여기서 ‘외부 저장소’란 React의 상태 관리 시스템 바깥에 있는 모든 데이터 소스를 의미합니다.\n예를 들어, localStorage, sessionStorage, 브라우저의 window.matchMedia API, 심지어 Redux나 Zustand 같은 서드파티 상태 관리 라이브러리의 스토어까지 모두 해당됩니다.\n과거의 문제점: ‘상태 찢어짐(State Tearing)’ React 18 이전에는 useState와 useEffect를 조합하여 외부 저장소를 구독하는 방식을 주로 사용했습니다.\n하지만 이 방식은 React 18의 ‘동시성 렌더링(Concurrent Rendering)’ 환경에서 치명적인 문제를 일으킬 수 있었습니다.\n바로 ‘상태 찢어짐(tearing)’ 현상입니다.\n동시성 렌더링 환경에서 React는 렌더링을 잠시 멈추거나, 다른 렌더링을 먼저 처리할 수 있습니다.\n이때 외부 저장소의 값이 변경되면, 화면의 일부 컴포넌트는 변경 전의 옛날 값을 보여주고, 다른 일부는 변경 후의 새로운 값을 보여주는 ‘불일치’ 상태가 발생할 수 있습니다.\nUI가 찢어진 것처럼 보이는 이 현상이 바로 ‘상태 찢어짐’입니다.\nuseSyncExternalStore는 바로 이 문제를 해결하기 위해 탄생했습니다.\n이 훅은 React의 렌더링 과정과 외부 데이터 소스의 동기화를 보장하여, 동시성 환경에서도 항상 일관된 상태를 유지하도록 만듭니다.\nuseSyncExternalStore의 세 가지 핵심 인자 이 훅은 세 개의 인자를 받습니다.\nuseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\nsubscribe: 외부 저장소의 ‘변화를 감지’하는 방법을 알려주는 함수입니다. 이 함수는 콜백 함수를 인자로 받아, 저장소에 변화가 생겼을 때 그 콜백을 호출하도록 구독(subscribe) 로직을 구현해야 합니다. 또한, 구독을 해지하는 함수를 반환해야 합니다. getSnapshot: 외부 저장소의 ‘현재 값’을 가져오는 방법을 알려주는 함수입니다. 이 함수는 저장소 데이터의 스냅샷을 반환해야 합니다. getServerSnapshot (선택 사항): 서버 사이드 렌더링(SSR) 시에 사용할 초기 스냅샷을 제공하는 함수입니다. 클라이언트와 서버의 초기 HTML이 일치하도록 보장하는 역할을 합니다. 구체적인 예제: LocalStorage와 테마 동기화하기 이제 사용자가 라이트/다크 테마를 선택하고, 그 선택이 여러 브라우저 탭에 걸쳐 동기화되는 예제를 만들어 보겠습니다.\n1단계: 커스텀 훅 useThemeStore 만들기 가장 먼저 localStorage의 변화를 감지하고 상태를 업데이트하는 로직을 담은 커스텀 훅을 만듭니다.\n// useThemeStore.ts import { useSyncExternalStore } from \u0026#34;react\u0026#34;; type Theme = \u0026#34;light\u0026#34; | \u0026#34;dark\u0026#34;; const THEME_STORAGE_KEY = \u0026#34;app-theme\u0026#34;; // \u0026#34;getSnapshot\u0026#34; 역할을 하는 함수: 현재 localStorage의 값을 읽어옵니다. const getThemeFromLocalStorage = (): Theme =\u0026gt; { return (localStorage.getItem(THEME_STORAGE_KEY) as Theme) || \u0026#34;light\u0026#34;; }; // \u0026#34;subscribe\u0026#34; 역할을 하는 함수: localStorage의 \u0026#39;storage\u0026#39; 이벤트를 구독합니다. const subscribe = (callback: () =\u0026gt; void): (() =\u0026gt; void) =\u0026gt; { window.addEventListener(\u0026#34;storage\u0026#34;, callback); // 구독 해지 함수를 반환합니다. return () =\u0026gt; { window.removeEventListener(\u0026#34;storage\u0026#34;, callback); }; }; // 우리의 최종 커스텀 훅 const useThemeStore = (): [Theme, (newTheme: Theme) =\u0026gt; void] =\u0026gt; { // useSyncExternalStore에 구독 함수와 스냅샷 함수를 전달합니다. const theme = useSyncExternalStore(subscribe, getThemeFromLocalStorage); const setTheme = (newTheme: Theme) =\u0026gt; { // 1. localStorage에 새로운 테마 값을 저장합니다. localStorage.setItem(THEME_STORAGE_KEY, newTheme); // 2. \u0026#39;storage\u0026#39; 이벤트를 수동으로 발생시킵니다. window.dispatchEvent(new Event(\u0026#34;storage\u0026#34;)); }; return [theme, setTheme]; }; export default useThemeStore; 여기서 가장 중요한 부분들을 자세히 살펴보겠습니다.\ngetThemeFromLocalStorage 함수는 useSyncExternalStore의 두 번째 인자인 getSnapshot의 역할을 합니다. 언제나 localStorage에서 최신 값을 읽어오죠. subscribe 함수는 useSyncExternalStore의 첫 번째 인자입니다. 브라우저의 storage 이벤트는 다른 탭이나 창에서 localStorage가 변경되었을 때 발생합니다. 이 이벤트를 구독함으로써 다른 탭의 변경 사항을 감지할 수 있습니다. setTheme 함수 안의 window.dispatchEvent(new Event(\u0026#34;storage\u0026#34;))는 이 솔루션의 ‘핵심 트릭’입니다. storage 이벤트는 기본적으로 ‘다른’ 탭에서의 변경만 감지합니다. 따라서 현재 탭에서 setTheme을 호출했을 때도 상태가 즉시 업데이트되게 하려면, 이벤트를 수동으로 발생시켜 subscribe의 콜백 함수가 실행되도록 만들어야 합니다. 2단계: 애플리케이션에 훅 적용하기 이제 우리가 만든 useThemeStore 훅을 사용하여 애플리케이션을 구성해 보겠습니다.\n이 훅 덕분에 각 컴포넌트는 localStorage 동기화의 복잡한 내부 로직을 전혀 알 필요 없이, 마치 일반적인 useState처럼 상태를 사용할 수 있습니다.\n// App.tsx import React from \u0026#34;react\u0026#34;; import Header from \u0026#34;./Header\u0026#34;; import ThemeToggler from \u0026#34;./ThemeToggler\u0026#34;; import Footer from \u0026#34;./Footer\u0026#34;; import useThemeStore from \u0026#34;./useThemeStore\u0026#34;; import styled from \u0026#34;styled-components\u0026#34;; const AppContainer = styled.div\u0026lt;{ themeType: \u0026#34;light\u0026#34; | \u0026#34;dark\u0026#34; }\u0026gt;` min-height: 100vh; background-color: ${({ themeType }) =\u0026gt; themeType === \u0026#34;light\u0026#34; ? \u0026#34;#ffffff\u0026#34; : \u0026#34;#333333\u0026#34;}; color: ${({ themeType }) =\u0026gt; (themeType === \u0026#34;light\u0026#34; ? \u0026#34;#000000\u0026#34; : \u0026#34;#ffffff\u0026#34;)}; // ... 기타 스타일 `; const App: React.FC = () =\u0026gt; { const [theme] = useThemeStore(); return ( \u0026lt;AppContainer themeType={theme}\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;ThemeToggler /\u0026gt; \u0026lt;Footer /\u0026gt; \u0026lt;/AppContainer\u0026gt; ); }; export default App; // ThemeToggler.tsx import React from \u0026#34;react\u0026#34;; import useThemeStore from \u0026#34;./useThemeStore\u0026#34;; const ThemeToggler: React.FC = () =\u0026gt; { const [theme, setTheme] = useThemeStore(); const toggleTheme = () =\u0026gt; { setTheme(theme === \u0026#34;light\u0026#34; ? \u0026#34;dark\u0026#34; : \u0026#34;light\u0026#34;); }; return ( \u0026lt;button onClick={toggleTheme}\u0026gt; Switch to {theme === \u0026#34;light\u0026#34; ? \u0026#34;Dark\u0026#34; : \u0026#34;Light\u0026#34;} Theme \u0026lt;/button\u0026gt; ); }; export default ThemeToggler; 이제 애플리케이션을 두 개의 브라우저 탭에서 열어 보세요.\n한쪽 탭에서 테마 변경 버튼을 누르면, 다른 쪽 탭의 테마도 즉시 함께 변경되는 마법 같은 경험을 할 수 있습니다.\nuseSyncExternalStore의 다른 활용 사례 이 훅의 활용 가능성은 무궁무진합니다.\n‘로그인 상태 동기화’: 한 탭에서 사용자가 로그아웃하면, 다른 모든 탭에서도 자동으로 로그아웃 상태가 반영되도록 할 수 있습니다. ‘장바구니 동기화’: 이커머스 사이트에서 한 탭에 상품을 담으면, 다른 탭의 장바구니 아이콘에도 즉시 상품 개수가 업데이트됩니다. ‘실시간 데이터 동기화’: WebSocket을 통해 들어오는 실시간 데이터를 모든 컴포넌트에서 일관되게 보여줄 수 있습니다. ‘전역 알림 관리’: 애플리케이션 전체에 걸쳐 표시되는 알림 상태를 동기화할 수 있습니다. 결론 useSyncExternalStore는 React  …","date":1751975471,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759583982,"objectID":"863f5f72713c24fe520421bee77869ee","permalink":"http://localhost:1313/posts/2025-07-08-react-usesyncexternalstore-guide-with-localstorage/","publishdate":"2025-07-08T11:51:11.079Z","relpermalink":"/posts/2025-07-08-react-usesyncexternalstore-guide-with-localstorage/","section":"posts","summary":"React의 상태 찢어짐(tearing) 문제는 무엇이며, React 18의 useSyncExternalStore 훅이 이 문제를 어떻게 해결하는지 알아봅니다. LocalStorage와 연동하여 여러 브라우저 탭 간에 상태를 동기화하는 실용적인 예제를 통해 완벽하게 마스터해 보세요.","tags":["hello","useSyncExternalStore","React 18","상태 관리","state management","LocalStorage","상태 동기화","React 훅"],"title":"React 18의 숨겨진 보석, useSyncExternalStore 완벽 가이드 (feat. LocalStorage)","type":"posts"},{"authors":null,"categories":null,"content":"안녕하세요?\n첫 티스토리부터 시작해서 점점 더 전문적인 지식을 갖추게 되었는데요.\n여러 가지 웹 프레임웍으로 여러 가지 사이트를 만들어 봤는데요.\n역시나 React가 가장 잘 맞는거 같습니다.\n그래서 앞으로 React 관련 공부나 블로깅에 주력코자 합니다.\n많이 읽어 주셔서 감사합니다.\nMy Sites mycodings.fly.dev cpro95.tistory.com mynewcodings.tistory.com mylotto.pages.dev KakaoWeb mytrivia.pages.dev mylyrivcs.pages.dev gamegongyak.blogspot.com ","date":1707825071,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759972747,"objectID":"b12471fdd907a48fcf044812e1eea8d8","permalink":"http://localhost:1313/posts/hello/","publishdate":"2024-02-13T11:51:11.079Z","relpermalink":"/posts/hello/","section":"posts","summary":"AI 시대에도 꾸준히 코딩 관련 정보를 공유코자 합니다.","tags":["hello"],"title":"안녕하세요? 주인장입니다.","type":"posts"}]