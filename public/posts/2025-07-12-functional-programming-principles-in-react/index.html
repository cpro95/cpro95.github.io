<!DOCTYPE html>
<html lang="ko">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='http://localhost:1313/js/theme-mode.js'></script>
    <link rel="stylesheet" href='http://localhost:1313/css/frameworks.min.css' />
    <link rel="stylesheet" href='http://localhost:1313/css/github.min.css' />
    <link rel="stylesheet" href='http://localhost:1313/css/github-style.css' />
    <link rel="stylesheet" href='http://localhost:1313/css/light.css' />
    <link rel="stylesheet" href='http://localhost:1313/css/dark.css' />
    <link rel="stylesheet" href='http://localhost:1313/css/syntax.css' />
    <title>React와 함수형 프로그래밍 - 더 나은 코드를 위한 핵심 원칙 - cpro95.github.io</title>
    
    <link rel="icon" type="image/x-icon" href='/images/github-mark.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    

    
    <meta name="description"
  content="React는 단순한 라이브러리가 아니라 사고방식입니다. 순수 함수, 불변성, 고차 컴포넌트, 컴포지션 등 함수형 프로그래밍의 핵심 원칙들이 어떻게 React를 더 예측 가능하고 강력하게 만드는지 깊이 있게 탐구합니다." />
<meta name="keywords"
  content='blog, web development' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="http://localhost:1313/posts/2025-07-12-functional-programming-principles-in-react/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="React와 함수형 프로그래밍 - 더 나은 코드를 위한 핵심 원칙 - cpro95.github.io" />
<meta name="twitter:description"
  content="React는 단순한 라이브러리가 아니라 사고방식입니다. 순수 함수, 불변성, 고차 컴포넌트, 컴포지션 등 함수형 프로그래밍의 핵심 원칙들이 어떻게 React를 더 예측 가능하고 강력하게 만드는지 깊이 있게 탐구합니다." />
<meta name="twitter:site" content="http://localhost:1313/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image"
  content="http://localhost:1313/">


<meta property="og:type" content="article" />
<meta property="og:title" content="React와 함수형 프로그래밍 - 더 나은 코드를 위한 핵심 원칙 - cpro95.github.io">
<meta property="og:description"
  content="React는 단순한 라이브러리가 아니라 사고방식입니다. 순수 함수, 불변성, 고차 컴포넌트, 컴포지션 등 함수형 프로그래밍의 핵심 원칙들이 어떻게 React를 더 예측 가능하고 강력하게 만드는지 깊이 있게 탐구합니다." />
<meta property="og:url" content="http://localhost:1313/posts/2025-07-12-functional-programming-principles-in-react/" />
<meta property="og:site_name" content="React와 함수형 프로그래밍 - 더 나은 코드를 위한 핵심 원칙" />
<meta property="og:image"
  content="http://localhost:1313/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2025-07-12 12:41:31 &#43;0000 UTC" />











</head>


<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="http://localhost:1313/">
        <img class="octicon" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          
          <form target="_blank" id="search-form" action="" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
            </label>
          </form>
          
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="http://localhost:1313/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  <div id="search-result" class="container-lg px-3 new-discussion-timeline" style="display: none;">
</div>

  
<div class="application-main">
  <div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="http://localhost:1313/">
                  <img class=" avatar-user"
                    src="/images/avatar.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="http://localhost:1313/">드리프트</a>
                  </span>
                  <span class="path-divider">/</span>
                  <span class="author">
                    <a href="http://localhost:1313/posts">Posts</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="http://localhost:1313/posts/2025-07-12-functional-programming-principles-in-react/">React와 함수형 프로그래밍 - 더 나은 코드를 위한 핵심 원칙</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Sat, 12 Jul 2025 12:41:31 &#43;0000"
                    class="no-wrap">
                    Sat, 12 Jul 2025 12:41:31 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Sat, 04 Oct 2025 22:19:42 &#43;0900"
                    class="no-wrap">
                    Sat, 04 Oct 2025 22:19:42 &#43;0900</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      3730 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="/tags/react">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      React
                    </a>
                    
                    <a class="muted-link mr-3" href="/tags/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      함수형 프로그래밍
                    </a>
                    
                    <a class="muted-link mr-3" href="/tags/%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      순수 함수
                    </a>
                    
                    <a class="muted-link mr-3" href="/tags/%EB%B6%88%EB%B3%80%EC%84%B1">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      불변성
                    </a>
                    
                    <a class="muted-link mr-3" href="/tags/%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      고차 컴포넌트
                    </a>
                    
                    <a class="muted-link mr-3" href="/tags/%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      컴포지션
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="react와-함수형-프로그래밍---더-나은-코드를-위한-핵심-원칙">React와 함수형 프로그래밍 - 더 나은 코드를 위한 핵심 원칙</h1>
<p><img src="https://blogger.googleusercontent.com/img/a/AVvXsEgr_P_vbKgrljls-Gm7_Q94A5hP7OGGDjiZ4NqZq0cUJXCAeOxSriFZ63Fo7ho_lEsmt12FiMbXbcDJham42JrUyfgIZh1Wjqm5xJzzk3myWV9Lzbqupz9NkwIb9NtsomHN7FiIGPDnwgrqDWOtBu86bPddi0h14xq8FI5lK3012XK6vxkGx3yQWs2xW7w=s16000" alt=""></p>
<p>우리는 React의 내부 메커니즘, 모범 사례, 디자인 패턴, 그리고 고급 개념들을 탐구합니다.</p>
<p>이 글들은 기본을 넘어 React가 내부적으로 어떻게 작동하는지 진정으로 이해하고자 하는 React 개발자들을 위해 작성되었습니다.</p>
<h2 id="서론-함수형-프로그래밍이란-무엇인가">서론: 함수형 프로그래밍이란 무엇인가?</h2>
<p>&lsquo;함수형 프로그래밍(Functional Programming)&lsquo;은 계산을 &lsquo;수학적 함수의 평가&rsquo;로 취급하고, &lsquo;상태 변경&rsquo;과 &lsquo;변경 가능한 데이터(mutable data)&lsquo;를 피하는 프로그래밍 접근 방식입니다.</p>
<p>이는 많은 개발자에게 더 익숙한 전통적인 &lsquo;명령형 프로그래밍&rsquo;과는 크게 다릅니다.</p>
<p>마치 누군가에게 식사를 준비하기 위해 상세한 단계별 지침을 주는 것(&lsquo;명령형&rsquo; 접근 방식)과, 재료와 적용할 변환 과정을 설명하는 레시피를 주는 것(&lsquo;함수형&rsquo; 접근 방식)의 차이를 생각해 보세요.</p>
<p>함수형 프로그래밍에서 우리는 따라야 할 단계보다는 &lsquo;데이터 변환&rsquo;에 집중합니다.</p>
<h3 id="다른-패러다임과의-차이점">다른 패러다임과의 차이점</h3>
<p>React에 특화된 함수형 개념에 뛰어들기 전에, 함수형 프로그래밍이 다른 패러다임과 어떻게 다른지 이해해 보겠습니다.</p>
<ul>
<li>&lsquo;명령형 프로그래밍&rsquo;: 프로그램의 상태를 시간에 따라 변경함으로써 &lsquo;어떻게&rsquo; 작업을 완수할지에 초점을 맞춥니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 명령형 접근 방식
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 외부 상태
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">sum</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">i</span>; <span style="color:#75715e">// 상태를 직접 변경(mutate)합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">sum</span>); <span style="color:#75715e">// 15
</span></span></span></code></pre></div><ul>
<li>&lsquo;함수형 프로그래밍&rsquo;: 데이터에 적용할 변환을 설명함으로써 &lsquo;무엇을&rsquo; 완수할지에 초점을 맞춥니다.
상태 변경을 피하고 순수한 변환을 선호합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 함수형 접근 방식
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">numbers</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sum</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">numbers</span>.<span style="color:#a6e22e">reduce</span>((<span style="color:#a6e22e">acc</span>, <span style="color:#a6e22e">current</span>) =&gt; <span style="color:#a6e22e">acc</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">current</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 새로운 값을 반환합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">sum</span>); <span style="color:#75715e">// 15
</span></span></span></code></pre></div><ul>
<li>&lsquo;객체 지향 프로그래밍(OOP)&rsquo;: 데이터와 동작을 캡슐화하는 &lsquo;객체&rsquo;를 중심으로 코드를 구성합니다.
상태는 이 패러다임의 중심입니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#75715e">// 객체 지향 접근 방식
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Counter</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 상태(데이터)를 객체 내부에 캡슐화
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">increment</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 객체 자신의 상태를 변경하는 메서드
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">count</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Counter</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">increment</span>(); <span style="color:#75715e">// 객체의 내부 상태가 변경됨
</span></span></span></code></pre></div><h2 id="react는-왜-함수형-프로그래밍을-선택했을까">React는 왜 함수형 프로그래밍을 선택했을까?</h2>
<p>React는 몇 가지 중요한 이유로 많은 함수형 프로그래밍 개념을 사용합니다.</p>
<ul>
<li>&lsquo;예측 가능성&rsquo;: 순수 함수는 동일한 입력에 대해 항상 동일한 결과를 생성하므로, 컴포넌트의 동작이 더 예측 가능하고 디버깅하기 쉬워집니다.</li>
<li>&lsquo;테스트 용이성&rsquo;: 부수 효과(side effects)가 없는 함수는 숨겨진 의존성이 없기 때문에 테스트하기가 더 쉽습니다.</li>
<li>&lsquo;합성(Composition)&rsquo;: 작은 함수들을 결합하여 복잡한 동작을 만들 수 있는 것처럼, React 컴포넌트들을 합성하여 완전한 사용자 인터페이스를 만들 수 있습니다.</li>
<li>&lsquo;상태 관리&rsquo;: 불변성(immutability)과 함수형 변환은 React가 변경 사항을 효율적으로 감지하고 렌더링 성능을 최적화할 수 있게 해줍니다.</li>
</ul>
<p>React는 순수 함수형 프로그래밍의 모든 측면을 엄격하게 따르지는 않더라도, 이러한 함수형 원칙들을 활용하여 더 예측 가능하고 유지보수하기 쉬운 프로그래밍 모델을 제공합니다.</p>
<h2 id="1-일급-객체로서의-함수-functions-as-first-class-values">1. 일급 객체로서의 함수 (Functions as First-Class Values)</h2>
<p>JavaScript에서 함수는 &lsquo;일급 객체&rsquo;입니다.</p>
<p>이는 함수가 언어의 다른 모든 값처럼 취급될 수 있음을 의미합니다.</p>
<p>이 특징은 함수형 프로그래밍의 기본이며 React에서 널리 사용됩니다.</p>
<p>실질적으로 이것은 JavaScript의 함수가 다음과 같은 일을 할 수 있다는 뜻입니다.</p>
<ul>
<li>변수에 할당되거나 자료 구조에 저장될 수 있습니다.</li>
<li>다른 함수에 인자로 전달될 수 있습니다.</li>
<li>다른 함수에 의해 반환될 수 있습니다.</li>
</ul>
<p>이 유연성은 함수가 일급 객체가 아닌 언어에서는 어렵거나 불가능한 디자인 패턴을 가능하게 합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#75715e">// 함수가 변수에 저장됩니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handleClick</span> <span style="color:#f92672">=</span> () =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Button clicked&#34;</span>);
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 함수가 prop으로 컴포넌트에 전달됩니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Button</span>({ <span style="color:#a6e22e">onClick</span>, <span style="color:#a6e22e">children</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">onClick</span>}&gt;{<span style="color:#a6e22e">children</span>}&lt;/<span style="color:#f92672">button</span>&gt;;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">App</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> &lt;<span style="color:#f92672">Button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">handleClick</span>}&gt;<span style="color:#a6e22e">Click</span> <span style="color:#a6e22e">here</span>&lt;/<span style="color:#f92672">button</span>&gt;;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="2-고차-컴포넌트-higher-order-components-hoc">2. 고차 컴포넌트 (Higher-Order Components, HOC)</h2>
<p>HOC는 React에서 일급 함수의 개념을 가장 강력하게 적용한 예시 중 하나입니다.</p>
<p>HOC는 &lsquo;컴포넌트를 인자로 받아, 새로운 기능이 추가된 새 컴포넌트를 반환하는 함수&rsquo;입니다.</p>
<p>이 기법은 컴포넌트 로직 재사용과 관심사 분리를 가능하게 합니다.</p>
<p>&lsquo;Hooks&rsquo;가 등장하기 전까지, HOC는 로직을 공유하는 가장 일반적인 방법이었습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#75715e">// 로딩 상태를 추가하는 HOC
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withLoading</span>(<span style="color:#a6e22e">Component</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 새 컴포넌트를 반환합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">WithLoadingComponent</span>({ <span style="color:#a6e22e">isLoading</span>, ...<span style="color:#a6e22e">props</span> }) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">isLoading</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> &lt;<span style="color:#f92672">div</span>&gt;<span style="color:#a6e22e">Loading</span>...&lt;/<span style="color:#f92672">div</span>&gt;;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 로딩이 아니면, 원본 컴포넌트를 렌더링합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> &lt;<span style="color:#f92672">Component</span> {<span style="color:#a6e22e">...props</span>} /&gt;;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 기본 컴포넌트
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">UserList</span>({ <span style="color:#a6e22e">users</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">ul</span>&gt;
</span></span><span style="display:flex;"><span>      {<span style="color:#a6e22e">users</span>.<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">user</span> =&gt; (
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">li</span> <span style="color:#a6e22e">key</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">id</span>}&gt;{<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">name</span>}&lt;/<span style="color:#f92672">li</span>&gt;
</span></span><span style="display:flex;"><span>      ))}
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#f92672">ul</span>&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 로딩 상태가 추가된 강화된 컴포넌트 생성
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">UserListWithLoading</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">withLoading</span>(<span style="color:#a6e22e">UserList</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 사용 예시
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">App</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">users</span>, <span style="color:#a6e22e">setUsers</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>([]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">isLoading</span>, <span style="color:#a6e22e">setIsLoading</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ... useEffect로 데이터 페칭
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> &lt;<span style="color:#f92672">UserListWithLoading</span> <span style="color:#a6e22e">isLoading</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">isLoading</span>} <span style="color:#a6e22e">users</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">users</span>} /&gt;;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>HOC는 로직 재사용에 매우 강력하지만, 여러 개를 중첩하면 JSX가 복잡해지는 &lsquo;래퍼 지옥(wrapper hell)&lsquo;이나 prop 이름 충돌 같은 단점도 있습니다.</p>
<p>현대 React에서는 대부분의 경우 &lsquo;커스텀 훅&rsquo;이 더 나은 대안으로 여겨집니다.</p>
<h2 id="3-순수-함수-pure-functions">3. 순수 함수 (Pure Functions)</h2>
<p>순수 함수는 함수형 프로그래밍의 핵심 개념입니다.</p>
<p>순수 함수란:</p>
<ul>
<li>동일한 인자로 호출될 때 항상 동일한 결과를 반환합니다.</li>
<li>관찰 가능한 &lsquo;부수 효과(side effects)&lsquo;가 없습니다.
(외부 변수 수정, API 요청, <code>console.log</code> 등)</li>
<li>오직 자신의 인자에만 의존합니다.</li>
</ul>
<p>React에서는 컴포넌트가 그 props에 대해 순수 함수처럼 동작하도록 노력해야 합니다.</p>
<p>동일한 props가 주어지면 항상 동일한 UI를 렌더링해야 하죠.</p>
<p>이 원칙 덕분에 React는 렌더링을 최적화할 수 있습니다.</p>
<p>만약 순수 컴포넌트의 props가 변경되지 않았다면, React는 결과가 동일할 것임을 알기 때문에 렌더링 과정을 건너뛸 수 있습니다.
(<code>React.memo</code>가 바로 이 원리를 이용합니다.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#75715e">// 순수 함수: 오직 매개변수에만 의존합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">calculateTotal</span>(<span style="color:#a6e22e">items</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">items</span>.<span style="color:#a6e22e">reduce</span>((<span style="color:#a6e22e">total</span>, <span style="color:#a6e22e">item</span>) =&gt; <span style="color:#a6e22e">total</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">price</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">item</span>.<span style="color:#a6e22e">quantity</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 순수 React 컴포넌트: 동일한 items prop에 대해 항상 동일한 UI를 렌더링합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">OrderSummary</span>({ <span style="color:#a6e22e">items</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">total</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">calculateTotal</span>(<span style="color:#a6e22e">items</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#f92672">p</span>&gt;<span style="color:#a6e22e">Total</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">$</span>{<span style="color:#a6e22e">total</span>.<span style="color:#a6e22e">toFixed</span>(<span style="color:#ae81ff">2</span>)}&lt;/<span style="color:#f92672">p</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="4-불변성-immutability">4. 불변성 (Immutability)</h2>
<p>&lsquo;불변성&rsquo;은 기존 데이터를 직접 수정하지 않고, 대신 원하는 변경 사항이 적용된 &lsquo;새로운 복사본&rsquo;을 만드는 원칙입니다.</p>
<p>React에서 불변성이 중요한 이유는, React가 변경 사항을 감지하고 DOM을 언제 업데이트할지 결정하는 방식 때문입니다.</p>
<p>React는 객체의 &lsquo;참조(reference)&lsquo;를 비교하여 무언가 변경되었는지 판단합니다.</p>
<p>만약 객체를 직접 수정하면(mutation), 객체의 메모리 주소, 즉 참조는 그대로 유지됩니다.</p>
<p>React는 <code>'이전 상태 === 새로운 상태'</code> 인지 매우 빠른 참조 비교 검사를 수행하는데, 참조가 동일하면 아무것도 바뀌지 않았다고 착각하고 리렌더링을 건너뛰게 됩니다.</p>
<h3 id="불변성을-지키는-방법-해야-할-것">불변성을 지키는 방법 (해야 할 것)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">TodoList</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">todos</span>, <span style="color:#a6e22e">setTodos</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>([
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>  ]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">toggleTodo</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">id</span> =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// map을 사용해 &#39;새로운 배열&#39;을 생성합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">setTodos</span>(
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">todos</span>.<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">todo</span> =&gt;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">todo</span>.<span style="color:#a6e22e">id</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">id</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">?</span> { ...<span style="color:#a6e22e">todo</span>, <span style="color:#a6e22e">completed</span><span style="color:#f92672">:</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">todo</span>.<span style="color:#a6e22e">completed</span> } <span style="color:#75715e">// 스프레드 연산자로 &#39;새로운 객체&#39;를 생성합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#f92672">:</span> <span style="color:#a6e22e">todo</span>
</span></span><span style="display:flex;"><span>      )
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="직접-수정하는-방법-피해야-할-것">직접 수정하는 방법 (피해야 할 것)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">TodoListBad</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">todos</span>, <span style="color:#a6e22e">setTodos</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useState</span>([
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* ... */</span>
</span></span><span style="display:flex;"><span>  ]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ❌ 나쁜 접근 방식 (직접 수정)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">toggleTodoBad</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">id</span> =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">todoIndex</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">todos</span>.<span style="color:#a6e22e">findIndex</span>(<span style="color:#a6e22e">todo</span> =&gt; <span style="color:#a6e22e">todo</span>.<span style="color:#a6e22e">id</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">id</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ❌ 기존 배열 내부의 객체를 직접 수정합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">todos</span>[<span style="color:#a6e22e">todoIndex</span>].<span style="color:#a6e22e">completed</span> <span style="color:#f92672">=</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">todos</span>[<span style="color:#a6e22e">todoIndex</span>].<span style="color:#a6e22e">completed</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 배열의 참조가 바뀌지 않았기 때문에 React는 변화를 감지하지 못합니다.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">setTodos</span>(<span style="color:#a6e22e">todos</span>);
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="5-커링과-합성-currying--composition">5. 커링과 합성 (Currying &amp; Composition)</h2>
<p>&lsquo;커링&rsquo;은 여러 인자를 받는 함수를, 각각 하나의 인자를 받는 함수들의 연속으로 변환하는 기법입니다.</p>
<p>이를 통해 더 일반적인 함수로부터 특화된 함수를 만들 수 있습니다.</p>
<p>React에서는 특히 여러 데이터를 필요로 하는 이벤트 핸들러를 만들 때 유용합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">ProductList</span>({ <span style="color:#a6e22e">products</span>, <span style="color:#a6e22e">onProductAction</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 커링된 함수: action =&gt; productId =&gt; event
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handleProductAction</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">action</span> =&gt; <span style="color:#a6e22e">productId</span> =&gt; <span style="color:#a6e22e">event</span> =&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">onProductAction</span>(<span style="color:#a6e22e">action</span>, <span style="color:#a6e22e">productId</span>);
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>      {<span style="color:#a6e22e">products</span>.<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">product</span> =&gt; (
</span></span><span style="display:flex;"><span>        &lt;<span style="color:#f92672">button</span> <span style="color:#a6e22e">onClick</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">handleProductAction</span>(<span style="color:#e6db74">&#34;view&#34;</span>)(<span style="color:#a6e22e">product</span>.<span style="color:#a6e22e">id</span>)}&gt;<span style="color:#a6e22e">View</span>&lt;/<span style="color:#f92672">button</span>&gt;
</span></span><span style="display:flex;"><span>      ))}
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>&lsquo;합성&rsquo;은 단순한 함수들을 결합하여 더 복잡한 함수를 만드는 원리입니다.</p>
<p>React에서는 작은 컴포넌트들을 조립하여 복잡한 UI를 만드는 방식으로 나타납니다.</p>
<p>상속보다 합성을 사용하는 것이 React에서는 강력히 권장되는 패턴이며, 이는 고도로 재사용 가능하고 모듈적인 컴포넌트를 만들 수 있게 해줍니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-jsx" data-lang="jsx"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">Card</span>({ <span style="color:#a6e22e">title</span>, <span style="color:#a6e22e">children</span> }) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">className</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;card&#34;</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#f92672">h2</span>&gt;{<span style="color:#a6e22e">title</span>}&lt;/<span style="color:#f92672">h2</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#f92672">div</span>&gt;{<span style="color:#a6e22e">children</span>}&lt;/<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#f92672">div</span>&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">App</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (
</span></span><span style="display:flex;"><span>    &lt;<span style="color:#f92672">Card</span> <span style="color:#a6e22e">title</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;User Profile&#34;</span>&gt;
</span></span><span style="display:flex;"><span>      &lt;<span style="color:#f92672">UserInfo</span> <span style="color:#a6e22e">user</span><span style="color:#f92672">=</span>{<span style="color:#a6e22e">user</span>} /&gt;
</span></span><span style="display:flex;"><span>    &lt;/<span style="color:#f92672">Card</span>&gt;
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="결론">결론</h2>
<p>함수형 프로그래밍은 React를 위한 코딩 스타일 이상입니다.</p>
<p>그것은 React의 설계와 아키텍처를 안내하는 철학입니다.</p>
<p>일급 함수, 순수 함수, 불변성, 커링, 합성 같은 원칙들을 채택함으로써, 우리는 더 예측 가능하고, 테스트하기 쉬우며, 유지보수하기 좋은 React 애플리케이션을 만들 수 있습니다.</p>
<p>이 접근 방식은 우리의 코드 작성 방식뿐만 아니라, 해결책을 설계하는 방식까지 변화시킵니다.</p>
<p>그것은 우리를 더 작고, 더 집중되고, 더 재사용 가능한 컴포넌트를 만들도록 밀어붙이며, 이는 결국 유지보수하고 발전시키기 더 쉬운 애플리케이션으로 이어집니다.</p>
</article>
              </div>
              
              
              <div class="paginate-container">
                <div class="BtnGroup">
                  <a rel="nofollow" class="btn btn-outline BtnGroup-item" href="http://localhost:1313/">Home</a>
                  <a rel="nofollow" class="btn btn-outline BtnGroup-item" href="http://localhost:1313/posts">Posts</a>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='http://localhost:1313/js/toc.js'></script>
<link rel="stylesheet" href='http://localhost:1313/css/toc.css' />

  


<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='http://localhost:1313/css/gitalk.css'>
<script src='http://localhost:1313/js/gitalk.min.js'></script>


<script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.18.0/js/md5.min.js"></script>

<script>
  const gitalk = new Gitalk({
    
    clientID: 'Ov23lifamEzU8X3iDFJl',
    clientSecret: 'ce2a5ca50bad6bd0dba565654d02669c13ff2147',
    repo: 'cpro95-gitalk',
    owner: 'cpro95',
    admin: ['cpro95'],
    distractionFreeMode: false,

    

    
    
    

    
    id: md5(location.pathname)

  });
  
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>

</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="http://localhost:1313/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Copyright © All rights reserved.</li>
      
      <li class="mr-3 mr-lg-0">GitHub and the Invertocat logo are trademarks of <a href="https://github.com/">GitHub, Inc.</a></li>
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>

</body>

<script type="application/javascript" src="http://localhost:1313/js/github-style.js"></script>





<script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script type="application/javascript" src='http://localhost:1313/js/search.js'></script>



</html>